#                   PROYECTO DE BOMBERMAN 
#                  BENJAMIN ORTIZ 2025064599
#                  STEADMAN MURILLO 2025097768
#           IC-1802 INTRODUCCION A LA PROGRAMACION 
#                     I SEMESTRE DE 2025


import pygame as pg
import time as t
import random 
import sys 
import os 

#Aqui epiezan las clases del juego
#----------------------------------------------------------COMMONS DE PYGAME---------------------------------------

# Clase SpriteSheet: Carga una hoja de sprites y permite obtener imágenes individuales.
class SpriteSheet (): 
    def __init__(self, image):
        self.sheet = image
    
    def get_image(self, frame, width, height, scale, colour):
        image = pg.Surface((width, height)).convert_alpha()
        image.blit(self.sheet, (0, 0), ((frame * width), 0, width, height))
        image = pg.transform.scale(image, (width * scale, height * scale))
        image.set_colorkey(colour)

        return image

# -------------------------------------------------------CLASES DEL JUEGO-------------------------------------------
# Clase Jugador: Representa al jugador en el juego.
class Jugador : 
    def __init__(self, area_juego, pos_x, pos_y, velocidad, spritesheet, frame_count, frame_w,frame_h, scale, colour): 
        self.area_juego = area_juego #superficie del juego donde se dibuja el jugador
        self.x = pos_x
        self.y = pos_y
        self.velocidad = velocidad              #velocidad del jugador
        self.spritesheet = spritesheet          #LA SPRITESHEET DEL JUGADOR
        self.frame_count = frame_count          #CAANTIDAD DE FRAMES DE LA SKIN DEL JUGAODR
        self.width_frame = frame_w
        self.height_frame = frame_h   #esto siempre es estatico. como las spritesheets son horizontales entonces esto que qeuda asi . 
        self.scale = scale                              #multiplicador de escala para el sprite
        self.colour = colour
        self.last_update = t.time()
        self.current_frame = 0
        self.current_skin = self.spritesheet.get_image(0, 30, 30, scale, colour)
     
    def animacion_skin(self) : 
        current_time = t.time()
        if current_time - self.last_update > 0.1 : # Cambio de frame cada 0.2 segundos
            self.last_update = current_time
            self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
            print (self.current_frame)
        self.current_skin = self.spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)

    def mover(self): #metodo para mover al jugador, recibe el frame actual y la velocidad: 
        #metodo para mover al jugador, recibe el frame actual
        self.animacion_skin()

        largo= self.area_juego.get_width() #ancho del frame
        alto= self.area_juego.get_height()   #alto del frame
        #verifica que el jugador no se salga del frame
        keys = pg.key.get_pressed() #mover el pene
        if keys[pg.K_LEFT] and self.x > 0:
            self.x -= self.velocidad
        if keys[pg.K_RIGHT] and self.x + self.width_frame < largo:
            self.x += self.velocidad
        if keys[pg.K_UP] and self.y > 0:
            self.y -= self.velocidad
        if keys[pg.K_DOWN] and self.y +  self.height_frame < alto:
            self.y += self.velocidad
        #actualiza la posicion del jugador en el frame  
        self.area_juego.blit(self.current_skin, (self.x, self.y))
class Jugador_1(Jugador): #clase hija de jugador, que hereda de la clase padre
    def __init__(self, area_juego, pos_x, pos_y, spritesheet,frame_count,F_w,f_H,scale,colour,habilidad):
        super().__init__( area_juego, pos_x, pos_y, 5, spritesheet, frame_count,F_w,f_H, scale, colour)
        self.habilidad=habilidad
        self.ejecutando_habilidad = False
        self.tiempo_inicio_habilidad = 0
        self.max_tiempo_habilidad = 5  # 5 segundos máximo
    def ejecutar_habilidad(self ) :
        keys = pg.key.get_pressed()
        current_time = t.time()
        # Iniciar habilidad al presionar espacio
        if keys[pg.K_SPACE] and not self.ejecutando_habilidad:
            self.ejecutando_habilidad = True
            self.tiempo_inicio_habilidad = current_time
            print(f"Iniciando habilidad: {self.habilidad}")
        
        # Detener si pasa el tiempo máximo
        if self.ejecutando_habilidad:
            tiempo_transcurrido = current_time - self.tiempo_inicio_habilidad
            if tiempo_transcurrido > self.max_tiempo_habilidad:
                self.ejecutando_habilidad = False
                print("Habilidad detenida por tiempo máximo")
        
        # Detener al soltar la tecla
        if not keys[pg.K_SPACE] and self.ejecutando_habilidad:
            self.ejecutando_habilidad = False
            print("Habilidad detenida al soltar espacio")
class Preview_J(Jugador_1) :
    def __init__(self, area_juego, pos_x, pos_y, spritesheet,frame_count,F_w,f_H,scale,colour):
        super().__init__(area_juego, pos_x, pos_y, spritesheet,frame_count,F_w,f_H,scale,colour,"placeholder")
        self.habilidad= "placeholder" #placeholder para la habilidad del jugador



        

#TODO : LITERALMENTE ABSOLUTAMENTE TODO.
#ocupo tipo scar tiempo. si en 0,5s no se presiona ninguna tecla entonces el sprote es el statico, si en n se presiona deacruerdo al movimiento cambia el sprite. sis e presiona el de habiliad, entones se muestra el speiret habilidad.

#-----------------------pygame------------------------------

#commons de pygame (literalmente el inicio de pygame)
pg.init()
screen= pg.display.set_mode((800, 600)) #tamano de pantalla
pg.display.set_caption("El hombre que tiraba bombas") #Nombre de la ventana
reloj = pg.time.Clock() #reloj comun para controlar FPS

#-----------------------GLOBALES------------------------------
estado= "juego" #se inicializa el estado del juego como "start", que representa el menu de inicio
#-----------------------SPRITES------------------------------

#placeholders 
#placeholder_skin= pg.image.load("assets/sprites/perro.png").convert_alpha() #placeholder para el skin del jugador
imp_sps_intangible= pg.image.load("assets\sprites\players\intangible\idle (2).png").convert_alpha() #placeholder para el sprite intangible
imp_sps_intalgible_hab= pg.image.load("assets\sprites\players\intangible\invisible.png").convert_alpha() #placeholder para el sprite intangible de habilidad
imp_sps_intangible_run= pg.image.load("assets\sprites\players\intangible\correr.png").convert_alpha() #placeholder para el sprite intangible de correr
game_surface = pg.Surface((800,450)) #superficie del juego, que es el fondo de la pantalla
#-----------------------JUGADORES------------------------------
#instancia del jugador 1    
spritesheet_idle_int= SpriteSheet(imp_sps_intangible) #crea una instancia de la clase SpriteSheet con el sprite del jugador
spritesheet_habilidad_int= SpriteSheet(imp_sps_intalgible_hab) #crea una instancia de la clase SpriteSheet con el sprite de habilidad del jugador
sritesheet_run_int = SpriteSheet(imp_sps_intangible_run) #crea una instancia de la clase SpriteSheet con el sprite de correr del jugador

Player_1 = Jugador_1(game_surface, 100, 100,spritesheet_idle_int,9,32,32,2,"black", "me gusta el pito") #crea una instancia del jugador 1 con el frame, posicion y skin

#estados de juego :
def pantalla_juego() : #ESTRO ES UN PLACEHOLDER PARA LA PANTALLA DE juego
    screen.fill("white")
    game_surface.fill("black")  # Llama al método mover del jugador 1 para dibujarlo en la pantalla
    Player_1.mover()
    Player_1.ejecutar_habilidad() 
    screen.blit(game_surface,(0,150))  # Dibuja la superficie del juego en la pantalla

def pantalla_creacion_niveles () : 
    screen.fill("black")  # Llama al método mover del jugador 1 para dibujarlo en la pantalla
    return

while True:
#cambiador de estado
    if estado == "juego":  # Si el estado es "juego", se muestra la pantalla de juego
        pantalla_juego()
    elif estado == "creacion_niveles":  # Si el estado es "creacion_niveles", se muestra la pantalla de creación de niveles
        pantalla_creacion_niveles()
    else:  # Si el estado no es reconocido, se muestra un mensaje de error
        print("Estado no reconocido")
    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()
            sys.exit()  

    pg.display.flip()
    reloj.tick(45)
