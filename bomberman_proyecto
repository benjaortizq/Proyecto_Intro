#                   PROYECTO DE BOMBERMAN 
#                  BENJAMIN ORTIZ 2025064599
#                  STEADMAN MURILLO 2025097768
#           IC-1802 INTRODUCCION A LA PROGRAMACION 
#                     I SEMESTRE DE 2025


import pygame as pg
import time as t
import threading as th
import random 
import sys 
import os 
#pinche benja
#Aqui epiezan las clases del juego  
#----------------------------------------------------------CLASES UTILES DE PYGAME---------------------------------------
class Reloj(th.Thread):
    def __init__(self, tiempo_inicial):
        super().__init__()
        self.tiempo = tiempo_inicial
        self.en_marcha = True
        self.isDaemon = False  # Para que el hilo se cierre con el programa principal
        self.pausado = False
        self.lock = th.Lock()  # Para sincronización
        
    def run(self):
        while self.en_marcha and self.tiempo > 0:
            with self.lock:
                if not self.pausado:
                    t.sleep(0.85)  # soy un ijueputa
                    self.tiempo -= 1
                    
    def detener(self):
        self.en_marcha = False
        
    def pausar(self):
        self.pausado = True
        
    def reanudar(self):
        self.pausado = False

# Clase SpriteSheet: Carga una hoja de sprites y permite obtener imágenes individuales.
class SpriteSheet (): 
    def __init__(self, image): 
        self.sheet = image  # Carga la imagen de la hoja de sprites
    
    def get_image(self, frame, width, height, scale, colour):
        image = pg.Surface((width, height)).convert_alpha()     # Crea una superficie para el frame
        image.blit(self.sheet, (0, 0), ((frame * width), 0, width, height))  # Copia el frame correspondiente de la hoja de sprites
        image = pg.transform.scale(image, (width * scale, height * scale))  # Escala la imagen al tamaño deseado
        image.set_colorkey(colour)      # Establece el color clave para hacer transparente el fondo

        return image
#CLASE BOTON: Representa un botón en la interfaz del juego.
class Boton : 
    def __init__(self, x, y, width, height, text, font,size, color, hover_color ):    # '"ALERTA  : EN FONT TIENE QUE RECIBIR LA STRING DE LA DIRECCION DE LA FUENTE, POR EJEMPLO "fonts/arial.ttf"'
        self.rect = pg.Rect(x, y, width, height)  # Crea un rectángulo para el botón
        self.text = text  # Texto del botón
        self.font = pg.font.Font(font,size)  # Fuente del texto
        self.color = color 
        self.size = size # Color normal del botón
        self.hover_color = hover_color  # Color al pasar el mouse sobre el botón
        self.last_mouse_state  = None   # Tipo de acción (por ejemplo, cambiar de estado)
    def check_click(self):
        mouse_pos = pg.mouse.get_pos()
        mouse_pressed = pg.mouse.get_pressed()[0]
        # Detectar solo el momento exacto cuando se presiona el botón  
        if self.rect.collidepoint(mouse_pos):
            if mouse_pressed and not self.last_mouse_state:  # Solo en el frame del clic inicial
                return True  # Retorna True si el botón fue presionado
            return False
        return False

    def draw(self, surface):
        mouse_pos = pg.mouse.get_pos()  # Obtiene la posición del mouse
        if self.rect.collidepoint(mouse_pos):  # Verifica si el mouse está sobre el botón
            pg.draw.rect(surface, self.hover_color, self.rect,int(self.size*0.55),int(self.size*0.2))  # Dibuja el botón con el color de hover
        else:
            pg.draw.rect(surface, self.color, self.rect,int(self.size*0.55),int(self.size*0.2))  # Dibuja el botón con el color normal
          # Establece el tamaño de la fuente
        text_surface = self.font.render(self.text, True, (255, 255, 255))  # Renderiza el texto del botón
        text_rect = text_surface.get_rect(center=self.rect.center)  # Centra el texto en el botón
        surface.blit(text_surface, text_rect)  # Dibuja el texto en la superficie

class HealthBar:
    def __init__(self, x, y, width, height, hp,color_f,color_h):
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.hp = hp  # Salud actual del jugador
        self.color_f = color_f
        self.color_h = color_h  # Color de la barra de salud    
    def draw(self, surface):
        ratio= self.hp / 100 # Calcula la proporción de salud actual respecto a la máxima
        pg.draw.rect(surface, self.color_f, (self.x, self.y, self.width, self.height))  # Dibuja el fondo de la barra de salud   
        pg.draw.rect(surface, self.color_h, (self.x, self.y, self.width * ratio, self.height))

class Healthbar_Player (HealthBar) :
    def __init__(self, x, y, width, height, hp, heart_texture, cant_vidas, font):
        super().__init__(x, y, width, height, hp, (255, 0, 0), (0, 255, 0))  # Llama al constructor de HealthBar con colores por defecto
        self.heart_texture = heart_texture  # Textura del corazón para la barra de salud
        self.cant_vidas = cant_vidas  # Cantidad de vidas del jugador
        self.font = font  # Fuente para mostrar la cantidad de vidas
    def draw_atributes(self, surface):
        surface.blit(self.heart_texture, (self.x - heart_texture.get_width()-3, self.y-5))  # Dibuja el corazón en la barra de salud
        vidas=self.font.render (f"x {self.cant_vidas}", True, (255, 255, 255)) # Renderiza la cantidad de vidas del jugador
        surface.blit(vidas, (self.x - heart_texture.get_width()-32, self.y+5))  # Dibuja la cantidad de vidas en la barra de salud


# -------------------------------------------------------CLASES DEL JUEGO-------------------------------------------
# Clase Jugador: Representa al jugador en el juego.

class Jugador : 
    def __init__(self, area_juego, pos_x, pos_y, velocidad, spritesheet_idle,spritesheet_habilidad, frame_count, frame_w,frame_h, scale, colour): 
        self.area_juego = area_juego #superficie del juego donde se dibuja el jugador
        self.x = pos_x
        self.y = pos_y
        self.velocidad = velocidad              #velocidad del jugador
        self.spritesheet_idle = spritesheet_idle
        self.spritesheet_habilidad = spritesheet_habilidad
        self.current_spritesheet = spritesheet_idle  # Por defecto usamos idle        #LA SPRITESHEET DEL JUGADOR
        self.frame_count = frame_count          #CAANTIDAD DE FRAMES DE LA SKIN DEL JUGAODR
        self.width_frame = frame_w
        self.height_frame = frame_h   #esto siempre es estatico. como las spritesheets son horizontales entonces esto que qeuda asi . 
        self.scale = scale                              #multiplicador de escala para el sprite
        self.colour = colour                  #color de fondo del sprite que se va a eliminar
        self.last_update = t.time()     #tiempo de la ultima actualizacion del frame
        self.current_frame = 0        #numero de frame que esta actualmente dibujandose.
        self.current_skin = self.current_spritesheet.get_image(0, 30, 30, scale, colour)
        self.mask= pg.mask.from_surface(self.current_skin)  # Crea una máscara del sprite actual para colisiones
    
    def cambiar_spritesheet(self, nuevo_spritesheet): #esto es para cambiar la spritesheet del jugador, por ejemplo cuando se ejecuta una habilidad
        self.current_spritesheet = nuevo_spritesheet #cambia el spritesheet actual al nuevo
        self.current_frame = 0  #reinicia el frame actual a 0
        self.last_update = t.time()     #reinicia el tiempo de la ultima actualizacion para que no se salte frames al cambiar de spritesheet
    
    def animacion_skin(self) : 
        current_time = t.time()
        if current_time - self.last_update > 0.1 : # Cambio de frame cada 0.2 segundos
            self.last_update = current_time
            self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
        self.current_skin = self.current_spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)
        self.mask = pg.mask.from_surface(self.current_skin)
        

    def colisiona_con(self, otro_objeto):
        # Calcular diferencia de posiciones (offset)
        offset_x = int(otro_objeto.x) - int(self.x)
        offset_y = int(otro_objeto.y) - int(self.y)
        return self.mask.overlap(otro_objeto.mask, (offset_x, offset_y)) is not None
    
    def mover(self): #metodo para mover al jugador, recibe el frame actual y la velocidad: 
        #metodo para mover al jugador, recibe el frame actual
        self.animacion_skin()
        largo = self.area_juego.get_width() #ancho del aarea de juego
        alto = self.area_juego.get_height()   #alto del area de juego

        ancho_frame = int(self.width_frame * self.scale)    #ancho real del frame del jugador
        alto_frame = int(self.height_frame * self.scale)    #alto real del frame del jugador

        keys = pg.key.get_pressed() #mover el pene
        if keys[pg.K_LEFT] and self.x > 0:  #verifica que el jugador no se salga del frame
            self.x -= self.velocidad #mueve al jugador a la izquierda
        if keys[pg.K_RIGHT] and self.x + ancho_frame < largo:
            self.x += self.velocidad    #mueve al jugador a la derecha
        if keys[pg.K_UP] and self.y > 0:
            self.y -= self.velocidad  #mueve al jugador hacia arriba
        if keys[pg.K_DOWN] and self.y +  alto_frame < alto:
            self.y += self.velocidad  #mueve al jugador hacia abajo
        #actualiza la posicion del jugador en el frame  
        self.area_juego.blit(self.current_skin, (self.x, self.y))
class Jugador_1(Jugador): #clase hija de jugador, que hereda de la clase padre
    def __init__(self, area_juego, pos_x, pos_y, velocidad,spritesheet_idle,spritesheet_hab,frame_count,F_w,f_H,scale,colour,habilidad, cant_vidas,color_habilidad, color_bajada ):
        super().__init__( area_juego, pos_x, pos_y, velocidad, spritesheet_idle,spritesheet_hab, frame_count,F_w,f_H, scale, colour)
        self.habilidad=habilidad
        self.vida=97 #vida del jugador
        self.ejecutando_habilidad = False
        self.tiempo_inicio_habilidad = 0
        self.max_tiempo_habilidad = 5  # 5 segundos máximo
        self.cant_vidas = cant_vidas  # Cantidad de vidas del jugador
        self.color_habilidad = color_habilidad  # Color de la habilidad
        self.color_subiendo =color_habilidad
        self.barra_habilidad = 0  # Tiempo de recarga de la habilidad
        self.color_bajada=color_bajada
        self.powerups= {"dano" : 0 , "vida":0}
        self.items = {"bombas":5, "velocidad" : 8 ,"escudo":2 }
        self.powerup_en_uso={"dano": False, "vida": False}
        self.item_en_uso={"bombas":False, "velocidad" : False ,"escudo":False }
        self.tiene_llave=False
    def ejecutar_habilidad(self ) :
        keys = pg.key.get_pressed()
        current_time = t.time()
        # Iniciar habilidad al presionar espacio
        if keys[pg.K_SPACE] and not self.ejecutando_habilidad and self.barra_habilidad >50:
            self.ejecutando_habilidad = True
            self.tiempo_inicio_habilidad = current_time
            self.cambiar_spritesheet(self.spritesheet_habilidad)
            print(f"Iniciando habilidad: {self.habilidad}")
        
        # Detener si pasa el tiempo máximo
        if self.ejecutando_habilidad:
            tiempo_transcurrido = current_time - self.tiempo_inicio_habilidad
            self.barra_habilidad -=1 if self.barra_habilidad >= 1 else self.barra_habilidad==1
            self.color_habilidad = self.color_bajada
            
            if tiempo_transcurrido > self.max_tiempo_habilidad or int(self.barra_habilidad)==0:
                self.ejecutando_habilidad = False
                self.cambiar_spritesheet(self.spritesheet_idle)
                print("Habilidad detenida por tiempo máximo")

        if not self.ejecutando_habilidad:
            self.color_habilidad=self.color_subiendo
            self.barra_habilidad = min(self.barra_habilidad + 1, 100)   #ni idea porque co 99 sirve pero con ese numero me deja la barra en 100 maximo xd  


#ocupo tipo scar tiempo. si en 0,5s no se presiona ninguna tecla entonces el sprote es el statico, si en n se presiona deacruerdo al movimiento cambia el sprite. sis e presiona el de habiliad, entones se muestra el speiret habilidad.
#_____________________________________________________________________________________________________
#CLASES DE LA MATRIZ O ENEMIGOS
#Clase Obstaculo 
class Obstaculo:
    def __init__(self, screen, x, y, texture):
        self.screen = screen
        self.x = x
        self.y = y
        self.texture = texture
        self.mask    = pg.mask.from_surface(self.texture)
        
    def draw(self):
        self.screen.blit(self.texture, (self.x, self.y))

    def colisiona_con(self, otro_objeto):
     # Calcular diferencia de posiciones (offset)
     offset_x = int(otro_objeto.x) - int(self.x)
     offset_y = int(otro_objeto.y) - int(self.y)
     return self.mask.overlap(otro_objeto.mask, (offset_x, offset_y)) is not None




#Class Enemigos
#Screen = area_juego
class Enemigos:
     def __init__(self, screen, x, y, velocidad, spritesheet_walk, spritesheet_death, frame_count, frame_w,frame_h, scale, colour, muerte,dir):
          self.screen = screen
          self.x = x
          self.y = y
          self.velocidad = velocidad
          self.current_spritesheet = spritesheet_walk
          self.frame_count = frame_count          #CAANTIDAD DE FRAMES DE LA SKIN DEL JUGAODR
          self.width_frame = frame_w
          self.height_frame = frame_h   #esto siempre es estatico. como las spritesheets son horizontales entonces esto que qeuda asi . 
          self.scale = scale                              #multiplicador de escala para el sprite
          self.colour = colour                  #color de fondo del sprite que se va a eliminar
          self.last_update = t.time()     #tiempo de la ultima actualizacion del frame
          self.current_frame = 0        #numero de frame que esta actualmente dibujandose.
          self.current_skin = self.current_spritesheet.get_image(0, 48, 48, self.scale, self.colour)
          self.mask= pg.mask.from_surface(self.current_skin)
          self.dir = dir
          self.spritesheet_death = spritesheet_death
          self.muerte = muerte
          

     def animacion_muerte(self):
          self.cambiar_spritesheet(self.spritesheet_death)
          self.muerte = True
          self.velocidad = 0
          self.animacion_skin()
 
    #line_of_sight
     def move(self):
        self.animacion_skin()
        # HORIZONTAL: dir 0 ← , dir 1 →
        if self.dir in (0, 1):
            
            dx = -self.velocidad if self.dir == 0 else self.velocidad
            new_x = self.x + dx
            if dx < 0:
                 self.current_skin = pg.transform.flip(self.current_skin, True, False)
                 self.current_skin.set_colorkey('black')

            if new_x <= 0:
                 self.dir = 1
            if new_x >= 770:
                 self.dir = 0
            # límites de pantalla
            if 0 < new_x < 770:
                self.x = new_x
        # VERTICAL: dir 2 ↑ , dir 3 ↓
        elif self.dir in (2, 3):
            dy = -self.velocidad if self.dir == 2 else self.velocidad
            new_y = self.y + dy
            if new_y <= 0:
                 self.dir = 3
            if new_y >= 480:
                 self.dir = 2
            if 0 < new_y < 480:
                self.y = new_y

        # Dibujo
        self.screen.blit(self.current_skin, (self.x, self.y))

     def auto_move(self):
                    self.move()
                    
                 
     def rebote(self):
          #solo rebota su hay una pared
          self.dir ^= 1          

     def cambiar_spritesheet(self, nuevo_spritesheet): #esto es para cambiar la spritesheet del jugador, por ejemplo cuando se ejecuta una habilidad
          self.current_spritesheet = nuevo_spritesheet #cambia el spritesheet actual al nuevo
          self.current_frame = 0  #reinicia el frame actual a 0
          self.last_update = t.time()     #reinicia el tiempo de la ultima actualizacion para que no se salte frames al cambiar de spritesheet
    
     def animacion_skin(self) : 
        current_time = t.time()
        if self.muerte:
             if current_time - self.last_update > 0.5 : # Cambio de frame cada 0.2 segundos
                    self.last_update = current_time
                    self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
             self.current_skin = self.current_spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)
             self.mask = pg.mask.from_surface(self.current_skin)
             if self.current_frame == 2:
                Lista_Enemigos_1.remove(self)
                  
        else:
          if current_time - self.last_update > 0.1 : # Cambio de frame cada 0.2 segundos
               self.last_update = current_time
               self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
          self.current_skin = self.current_spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)
          self.mask = pg.mask.from_surface(self.current_skin)
    
     def colisiona_con(self, otro_objeto):
        # Calcular diferencia de posiciones (offset)
        offset_x = int(otro_objeto.x) - int(self.x)
        offset_y = int(otro_objeto.y) - int(self.y)
        return self.mask.overlap(otro_objeto.mask, (offset_x, offset_y)) is not None
     


#Class Bomba_sprite
class Bomba:
    
     def __init__(self, screen, x, y, spritesheet_bomba, frame_count, frame_w,frame_h, scale, colour, explosion):
          self.screen = screen
          self.x = x
          self.y = y
          self.current_spritesheet = spritesheet_bomba
          self.frame_count = frame_count          #CAANTIDAD DE FRAMES DE LA SKIN DEL JUGAODR
          self.width_frame = frame_w
          self.height_frame = frame_h   #esto siempre es estatico. como las spritesheets son horizontales entonces esto que qeuda asi . 
          self.scale = scale                              #multiplicador de escala para el sprite
          self.colour = colour                  #color de fondo del sprite que se va a eliminar
          self.last_update = t.time()     #tiempo de la ultima actualizacion del frame
          self.current_frame = 0        #numero de frame que esta actualmente dibujandose.
          self.current_skin = self.current_spritesheet.get_image(0, 48, 48, self.scale, self.colour)
          self.mask= pg.mask.from_surface(self.current_skin)
          self.bomba_animacion = explosion

     def animate(self):
       if self.bomba_animacion:
          self.animacion_skin()
          if self.current_frame == 4:
               self.bomba_animacion = False
               E_1.bomba_animacion = True
          self.screen.blit(self.current_skin, (self.x, self.y))


     def auto_animate(self):
                    self.animate()

     def cambiar_spritesheet(self, nuevo_spritesheet): #esto es para cambiar la spritesheet del jugador, por ejemplo cuando se ejecuta una habilidad
        self.current_spritesheet = nuevo_spritesheet #cambia el spritesheet actual al nuevo
        self.current_frame = 0  #reinicia el frame actual a 0
        self.last_update = t.time()     #reinicia el tiempo de la ultima actualizacion para que no se salte frames al cambiar de spritesheet
    
     def animacion_skin(self) : 
        current_time = t.time()
        if current_time - self.last_update > 0.4 : # Cambio de frame cada 0.2 segundos
            self.last_update = current_time
            self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
        self.current_skin = self.current_spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)
        self.mask = pg.mask.from_surface(self.current_skin)
    
     def colisiona_con(self, otro_objeto):
        # Calcular diferencia de posiciones (offset)
        offset_x = int(otro_objeto.x) - int(self.x)
        offset_y = int(otro_objeto.y) - int(self.y)
        return self.mask.overlap(otro_objeto.mask, (offset_x, offset_y)) is not None

class Bomba_Matriz(Bomba):
     def __init__(self, screen, x, y, spritesheet_bomba, frame_count, frame_w, frame_h, scale, colour, explosion):
          super().__init__(screen, x, y, spritesheet_bomba, frame_count, frame_w, frame_h, scale, colour, explosion)

     def animate_matriz(self):
       if self.bomba_animacion:
          self.animacion_skin()
          if self.current_frame == 4:
               matriz[self.y//48][self.x//48] = 9
               lista_B.remove(self)
          self.screen.blit(self.current_skin, (self.x, self.y))

     def auto_animate(self):
                    self.animate_matriz()

class Explosion:
     def __init__(self, screen, x, y, spritesheet_exp, frame_count, frame_w,frame_h, scale, colour, explosion):
          self.screen = screen
          self.x = x
          self.y = y
          self.current_spritesheet = spritesheet_exp
          self.frame_count = frame_count          #CAANTIDAD DE FRAMES DE LA SKIN DEL spritesheet
          self.width_frame = frame_w
          self.height_frame = frame_h   #esto siempre es estatico. como las spritesheets son horizontales entonces esto que qeuda asi . 
          self.scale = scale                              #multiplicador de escala para el sprite
          self.colour = colour                  #color de fondo del sprite que se va a eliminar
          self.last_update = t.time()     #tiempo de la ultima actualizacion del frame
          self.current_frame = 0        #numero de frame que esta actualmente dibujandose.
          self.current_skin = self.current_spritesheet.get_image(0, 48, 48, self.scale, self.colour)
          self.mask= pg.mask.from_surface(self.current_skin)
          self.bomba_animacion = explosion

     def animate(self):
       if self.bomba_animacion:
          self.animacion_skin()
          if self.current_frame == 3:
               E_1.bomba_animacion = False
          self.screen.blit(self.current_skin, (self.x, self.y))


     def auto_animate(self):
                    self.animate()

     def cambiar_spritesheet(self, nuevo_spritesheet): #esto es para cambiar la spritesheet del jugador, por ejemplo cuando se ejecuta una habilidad
        self.current_spritesheet = nuevo_spritesheet #cambia el spritesheet actual al nuevo
        self.current_frame = 0  #reinicia el frame actual a 0
        self.last_update = t.time()     #reinicia el tiempo de la ultima actualizacion para que no se salte frames al cambiar de spritesheet
    
     def animacion_skin(self) : 
        current_time = t.time()
        if current_time - self.last_update > 0.1 : # Cambio de frame cada 0.2 segundos
            self.last_update = current_time
            self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
        self.current_skin = self.current_spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)
        self.mask = pg.mask.from_surface(self.current_skin)
    
     def colisiona_con(self, otro_objeto):
        # Calcular diferencia de posiciones (offset)
        offset_x = int(otro_objeto.x) - int(self.x)
        offset_y = int(otro_objeto.y) - int(self.y)
        return self.mask.overlap(otro_objeto.mask, (offset_x, offset_y)) is not None
     
class Explosion_Matriz(Explosion):
     def __init__(self, screen, x, y, spritesheet_exp, frame_count, frame_w, frame_h, scale, colour, explosion):
          super().__init__(screen, x, y, spritesheet_exp, frame_count, frame_w, frame_h, scale, colour, explosion)
          self.matriz = matriz
          # Flags por dirección: False hasta que marque el primer '*'
          self.star_up = False
          self.star_down = False
          self.star_right = False
          self.star_left = False

     def animate_matriz(self):
       if self.bomba_animacion:
          self.animacion_skin()
          if self.current_frame == 3:
               lista_E.remove(self)
          self.screen.blit(self.current_skin, (self.x, self.y))
     
     def auto_animate(self):
                    self.animate_matriz()

     
class Explosion_Matriz_Lados(Explosion_Matriz):
     def __init__(self, screen, x, y, spritesheet_exp, frame_count, frame_w, frame_h, scale, colour, explosion, direccion):
          super().__init__(screen, x, y, spritesheet_exp, frame_count, frame_w, frame_h, scale, colour, explosion)
          self.dir = direccion

     def animate_matriz(self):
       if self.bomba_animacion:
          self.animacion_skin()
          if self.dir == 'u':
               self.current_skin = pg.transform.rotate(self.current_skin, 90)
               self.current_skin.set_colorkey('black')
          if self.dir == 'd':
               self.current_skin = pg.transform.rotate(self.current_skin, 270)
               self.current_skin.set_colorkey('black')
          if self.dir == 'a':
               self.current_skin = pg.transform.flip(self.current_skin, False, False)
               self.current_skin.set_colorkey('black')

          if self.dir == 's':
               self.current_skin = pg.transform.rotate(self.current_skin, 90)
               self.current_skin.set_colorkey('black')
          if self.dir == 'w':
               self.current_skin = pg.transform.rotate(self.current_skin, 270)
               self.current_skin.set_colorkey('black')

          if self.dir == 'f':
               self.current_skin = pg.transform.flip(self.current_skin, True, False)
               self.current_skin.set_colorkey('black')

          if self.current_frame == 3:
              lista_EL.remove(self)
          self.screen.blit(self.current_skin, (self.x, self.y))

     def animacion_skin(self) : 
        current_time = t.time()
        if current_time - self.last_update > 0.1 : # Cambio de frame cada 0.2 segundos
            self.last_update = current_time
            self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
        self.current_skin = self.current_spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)
        self.mask = pg.mask.from_surface(self.current_skin)

     def auto_animate(self):
                    self.animate_matriz()


#-----------------------pygame------------------------------

#commons de pygame (literalmente el inicio de pygame)
pg.init()
screen= pg.display.set_mode((816, 624)) #tamano de pantalla
pg.display.set_caption("El hombre que tiraba bombas") #Nombre de la ventana
tiempo_juego= Reloj(300)
reloj = pg.time.Clock() #reloj comun para controlar FPS


#-----------------------GLOBALES------------------------------
estado = "seleccion_personaje" #se inicializa el estado del juego como "start", que representa el menu de inicio (ahorita esta en seleccion de pers por unas pruebas q taba haciendo)

#Globales Steadman
obstacles = [] #lista de colisiones con obstaculos
obstacles_R = [] #lista de los rompibles
nivel = 1 #nivel inicial
matriz = [] #la matriz extraida del nivel inicial
Lista_Enemigos_1 = [] #la lista de los enemigos, esta solo posee los enemigos del nivel 1 o los mas sencillos
Fuerza_exp = 4 #Esto dice la fuerza de la explosion, se va a expandir en casillas en forma de cruz, si es 1 es una casilla extra
lista_B = [] #lista de bombas, solo para multiples animaciones a la vez
lista_E = [] #lista de explosiones, solo para multiples 
lista_EL = [] #lista para las explosiones extra o de lado o de borde
bomba_in_bounds = False
#___________________Enemigos y Aparicion de obstaculos________________________
CELL_SIZE = 48 #tamaño por celda para la aparicion de todo XDXDXDXDX
W_GRID = 17 #debido a que no es un cuadrado se debe definir un tamaño por ancho y alto
H_GRID = 13

primera_vez = True #debido a que ciertas cosas SOLO se deben generar una vez por nivel, como ver sus posiciones, se hace este booleano

#-----------------------GLOBALES Y CARACTERISTICAS DEL JUEGO------------------------------
puntaje_nivel=0
puntaje_final=0
global_fade=False

#-------------area de juego-----------
game_surface = pg.Surface((816,528)) #*! ya cambie el tamano del frame enves de 624 a 524, estaba pintando el frame 100 pix hacia abajo y hacia que pete todo

#------------------------TEXTURAS------------------------------
heart_texture = pg.image.load("assets/textures/heart.png").convert_alpha() #carga la textura del corazon
#--------------------FONDOS-----------------------------------
pos_par_men= [0] * 7
fondo_p_men=[ pg.image.load("assets\Backgrounds\opciones\layer5.png").convert_alpha() ,pg.image.load("assets\Backgrounds\opciones\layer4.png").convert_alpha() ,pg.image.load("assets\Backgrounds\opciones\layer3.png").convert_alpha() ,pg.image.load("assets\Backgrounds\opciones\layer2.png").convert_alpha() ,pg.image.load("assets\Backgrounds\opciones\layer1.png").convert_alpha() ,pg.image.load("assets\Backgrounds\opciones\layer0.png").convert_alpha() ]
fondos_p_op = [pg.image.load("assets/backgrounds/menu/layer3.png"),pg.image.load("assets/backgrounds/menu/layer2.png"),pg.image.load("assets/backgrounds/menu/layer1.png"),pg.image.load("assets/backgrounds/menu/layer0.png")]
#------------------------SPRITES DE JUGADORES------------------------------
sps_habilidades= pg.image.load ("assets\Textures\habilities.png").convert_alpha()
sps_items = pg.image.load("assets\Textures\items.png").convert_alpha()
sps_powerups=pg.image.load("assets\Textures\powerups.png").convert_alpha()

#--- Intangible ----
preview_intangible = pg.image.load("assets\sprites\players\Intangible\preview.png").convert_alpha() 
imp_sps_intangible= pg.image.load("assets\sprites\players\Intangible\idle.png").convert_alpha() #placeholder para el sprite intangible
imp_sps_intalgible_hab= pg.image.load("assets\sprites\players\Intangible\especial.png").convert_alpha() #placeholder para el sprite intangible de habilidad
imp_sps_intangible_run= pg.image.load("assets\sprites\players\Intangible\walk.png").convert_alpha() #placeholder para el sprite intangible de correr
#----tactico----
preview_tactico = pg.image.load("assets\sprites\players\Tactico\preview.png").convert_alpha() 
imp_sps_tactico = pg.image.load("assets\sprites\players\Tactico\idle.png").convert_alpha() #placeholder para el sprite intangible de correr
imp_sps_tactico_hab =pg.image.load("assets\sprites\players\Tactico\especial.png").convert_alpha() #placeholder para el sprite intangible de correr

#---kamikaze---
preview_kamikaze = pg.image.load("assets\sprites\players\Kamikaze\preview.png").convert_alpha() 
imp_sps_kamikaze = pg.image.load("assets\sprites\players\Kamikaze\idle.png").convert_alpha() #placeholder para el sprite intangible de correr
imp_sps_kamikaze_hab =pg.image.load("assets\sprites\players\kamikaze\especial.png").convert_alpha() #placeholder para el sprite intangible de correr



#-----------------------SPRITESHEET DE JUGADORES ------------------------------
spritesheet_habilidades_prev= SpriteSheet (sps_habilidades)
spritecheet_items= SpriteSheet (sps_items)
spritesheet_powerups=SpriteSheet(sps_powerups)

#Invencible 
spritesheet_idle_int = SpriteSheet(imp_sps_intangible) #crea una instancia de la clase SpriteSheet con el sprite del jugador
spritesheet_habilidad_int = SpriteSheet(imp_sps_intalgible_hab) #crea una instancia de la clase SpriteSheet con el sprite de habilidad del jugador
sritesheet_run_int = SpriteSheet(imp_sps_intangible_run) #crea una instancia de la clase SpriteSheet con el sprite de correr del jugador

#tactico
spritesheet_idle_tac= SpriteSheet(imp_sps_tactico) #crea una instancia de la clase SpriteSheet con el sprite del jugador
spritesheet_habilidad_tac = SpriteSheet(imp_sps_tactico_hab) #crea una instancia de la clase SpriteSheet con el sprite de habilidad del jugador
sritesheet_run_tac = SpriteSheet(imp_sps_tactico_hab) #crea una instancia de la clase SpriteSheet con el sprite de correr del jugador

#kamikaze
spritesheet_idle_kam = SpriteSheet(imp_sps_kamikaze) #crea una instancia de la clase SpriteSheet con el sprite del jugador
spritesheet_habilidad_kam = SpriteSheet(imp_sps_kamikaze_hab) #crea una instancia de la clase SpriteSheet con el sprite de habilidad del jugador
sritesheet_run_kam = SpriteSheet(imp_sps_intangible_run) #crea una instancia de la clase SpriteSheet con el sprite de correr del jugador


Player_1 = None
#ds
font_tit= pg.font.Font("fonts\\Upheavt.ttf",60)
font_tit1= pg.font.Font("fonts\\Upheavt.ttf",50)

#fonts pixeltype
font = pg.font.Font("fonts/Pixeltype.ttf", 35) #fuente para mostrar info de cada skin del player
font0= pg.font.Font("fonts/Pixeltype.ttf", 30) #fuente para mostrar info de cada skin del player
font1= pg.font.Font("fonts/Pixeltype.ttf", 50) #fuente para mostrar titulo de cada skin de player   
skin_seleccionada = 0                   #variable global para controlar la skin que selecciona en la aprte de seleccion de jugador (skin)
skin_viendo=0


##BOTONES GLOBALES 
boton_siguiente_opcion= Boton(300, 500, 150, 30, "Siguiente", "fonts/Pixeltype.ttf", 28, (44, 62, 80), (52, 73, 94 )) #"crea un boton de siguiente opcion (tiene que estar afuera por tipo int)
boton_seleccionar = Boton(300, 540, 150, 30, "Seleccionar", "fonts/Pixeltype.ttf", 28, (44, 62, 80), (52, 73, 94 ) ) #crea un boton de seleccionar

prev_siguiente = False #variable para controlar si se ha hecho clic en el botón de siguiente opción
prev_seleccion = False  #variable para controlar si se ha hecho clic en el botón de seleccionar

#_______Sprites Enemigos Steadman
#-----------------------SPRITES------------------------------
#Obstaculos
sps_obstacles = pg.image.load("assets\Textures\Bricks.png")
spritesheet_Obstaculos = SpriteSheet(sps_obstacles)
Obstaculo_I = spritesheet_Obstaculos.get_image(1,64,64,0.75,'white')
Obstaculo_R = spritesheet_Obstaculos.get_image(4,64,64,0.75,'white')

#Floor
sps_floor = pg.image.load("assets\Textures\Floor.png")
spritesheet_Floor = SpriteSheet(sps_floor)
Floor_corner0 = spritesheet_Floor.get_image(0,64,64,0.75,'white')
Floor_corner1 = pg.transform.rotate(Floor_corner0,90)
Floor_corner2 = pg.transform.rotate(Floor_corner0,180)
Floor_corner3 = pg.transform.rotate(Floor_corner1,180)
Floor_up = spritesheet_Floor.get_image(1,64,64,0.75,'white')
Floor_down = pg.transform.rotate(Floor_up,180)
Floor_lside = spritesheet_Floor.get_image(3,64,64,0.75,'white')
Floor_rside = pg.transform.rotate(Floor_lside,180)
Floor_nothing = spritesheet_Floor.get_image(4,64,64,0.75,'white')

#Enemigos
sps_perro_cañon = pg.image.load("assets\sprites\enemies\perro_canon\Walk.png")
spritesheet_perro_cañon = SpriteSheet(sps_perro_cañon)
#Perro cañon muerte
sps_perro_muerte = pg.image.load("assets\sprites\enemies\perro_canon\Death.png")
spritesheet_perro_muerte = SpriteSheet(sps_perro_muerte)
#Bomba
sps_bomba = pg.image.load("assets\Textures\Bomba\Bomba.png")
spritesheet_Bomba = SpriteSheet(sps_bomba)

#Explosion_Centro:
sps_exp_centro = pg.image.load("assets\Textures\Bomba\explosion_c.png")
spritesheet_exp_c = SpriteSheet(sps_exp_centro)

#Explosion Borde:
sps_exp_borde = pg.image.load("assets\Textures\Bomba\explosion_b.png")
spritesheet_exp_b = SpriteSheet(sps_exp_borde)
#Explosion Lado:
sps_exp_lado = pg.image.load("assets\Textures\Bomba\explosion_l.png")
spritesheet_exp_l = SpriteSheet(sps_exp_lado)

#FUNCIONES DE LA PANTALLA MENU
def bg_men_parallax(): 
    global fondo_p_men, pos_par_men
    parallax_speeds = [0.1, 0.01, 0.1, 0.2, 0.3, 0.5 ]
    
    # Dibujar capas desde la más lejana (0) a la más cercana (6)
    for i in range (len (fondo_p_men)) :
        # Calcular nueva posición (movimiento infinito)
        pos_par_men[i] -= parallax_speeds[i]
        img= pg.transform.scale (fondo_p_men[i],(fondo_p_men[i].get_width()*0.25,fondo_p_men[i].get_height()*0.25) if 0<i<5  else((fondo_p_men[i].get_width()*0.55,fondo_p_men[i].get_height()*0.55) ))
        
        # Reiniciar posición cuando la imagen sale completamente de la pantalla
        if pos_par_men[i] <= -img.get_width():
            pos_par_men[i] = 0
        
        # Dibujar dos copias para el efecto de scroll infinito
        screen.blit(img, (pos_par_men[i], (0 )))
        screen.blit(img, (pos_par_men[i] + img.get_width(), 0))
def bg_opc_parallax():
    global fondos_p_op
    factores = [0.1, 0.3, 0.5, 0.7]

    mouse_pos = pg.mouse.get_pos()   
    """Dibuja el fondo con efecto parallax basado en la posición del mouse"""
    mouse_x, mouse_y = mouse_pos
    
    # Calcular desplazamiento relativo al centro
    rel_x = (mouse_x - 816 // 2) / (816 // 2)
    rel_y = (mouse_y - 624 // 2) / (624 // 2)
    
    # Dibujar capas desde la más lejana (0) a la más cercana (3)
    for i, fondo in enumerate(fondos_p_op):
        # Calcular desplazamiento para esta capa
        fondo=pg.transform.scale(fondo, (1400,780))
        offset_x = rel_x * factores[i] * 100
        offset_y = rel_y * factores[i] * 100
        
        # Posición de dibujo (centrada con offset)
        pos_x = (816 - fondo.get_width()) // 2 + offset_x
        pos_y = (624 - fondo.get_height()) // 2 + offset_y
        
        screen.blit(fondo, (pos_x, pos_y))
def fade_in_from_white(duration_ms=2000):
    # Capturar la escena actual como fondo estático
    background = screen.copy()
    
    overlay = pg.Surface(screen.get_size(), pg.SRCALPHA)
    overlay.fill((255, 255, 255))
    start_time = pg.time.get_ticks()
    clock = pg.time.Clock()
    
    running = True
    while running:
        screen.blit(background ,(0,0))
        elapsed = pg.time.get_ticks() - start_time
        progress = min(1, elapsed / duration_ms)
        
        if progress >= 1:
            alpha = 0
            running = False
        else :
            alpha = 255-int(255 * progress)
            print (alpha)
        
        overlay.set_alpha(alpha)
        screen.blit(overlay, (0, 0))
        pg.display.flip()
        
        # Manejo de eventos sin bloquear
        for evt in pg.event.get():
            if evt.type == pg.QUIT:
                pg.quit()
                sys.exit()
        
        clock.tick(60)


#FUNCION PANTALLA TITULO
def pantalla_titulo () :
    global global_fade
    bg_men_parallax()
    titulo1= font_tit.render("EL HOMBRE", False, "white")
    titulo2= font_tit.render("Que tiraba bombas", False, "white")
    screen.blit (titulo1,(250,50))
    screen.blit(titulo2,(120,90))
    if not global_fade :
        fade_in_from_white() 
        global_fade=True
    
    




#FUNCIONES PARA LA PANTALLA DE JUEGO 

#Funcion para dibujar GUI
def dibujar_gui() :
    global tiempo_juego, puntaje_nivel
    screen.fill((24,24,24))
    lista_pw_uso = ["vida","dano"]
    texto_tiempo=font0.render(f"Tiempo : {tiempo_juego.tiempo}", False , "white")
    texto_puntaje_nivel = font0.render(f"Puntaje : {puntaje_nivel}",False,"white")

    
    default_pw = spritesheet_powerups.get_image(2, 64, 64, 1, "black")
    default_pw_p = spritesheet_powerups.get_image(2, 64, 64, 0.5, "black")

    powerup_sprites = {"vida": [spritesheet_powerups.get_image(0, 64, 64, 1, "black"),spritesheet_powerups.get_image(0, 64, 64, 0.5, "black")],"dano": [spritesheet_powerups.get_image(1, 64, 64, 1, "black"),spritesheet_powerups.get_image(1, 64, 64, 0.5, "black")]}
    pw_uso_1 = default_pw
    pw_uso_2 = default_pw_p
    if len(lista_pw_uso) >= 1:
        nombre1 = lista_pw_uso[0]
        sprites  = powerup_sprites.get(nombre1)
        if sprites:
            pw_uso_1 = sprites[0]
        # Si hay un segundo power‑up, úsalo en la ranura 2
        if len(lista_pw_uso) == 2:
            nombre2 = lista_pw_uso[1]
            sprites2  = powerup_sprites.get(nombre2)
            if sprites2:
                pw_uso_2 = sprites2[1]

    # Ahora dibuja pw_uso_1 y pw_uso_2 donde corresponda en tu GUI
    vida_jugador=Healthbar_Player (73, 15, 110, 20, Player_1.vida, heart_texture,Player_1.cant_vidas,font0)  # Dibuja la barra de salud del jugador
    vida_jugador.draw(screen)  # Dibuja la barra de salud en la superficie del juego
    vida_jugador.draw_atributes(screen)  # Dibuja los atributos de la barra de salud en la superficie del juego
    habilidad_jugador= HealthBar(73, 55, 110, 20, Player_1.barra_habilidad, (129, 133, 137), Player_1.color_habilidad)  # Dibuja la barra de habilidad del jugador
    habilidad_jugador.draw(screen)  # Dibuja la barra de habilidad en la superficie del juego
    icono_habilidad= spritesheet_habilidades_prev.get_image(skin_seleccionada, 128,128,0.5,"black")
    bombas_img=spritecheet_items.get_image(0,64,64,1.5,"black")
    velocidad_img=spritecheet_items.get_image(1,64,64,1.5,"black")
    escudo_img=spritecheet_items.get_image(2,64,64,1.5,"black")
    cant_bombas =Player_1.items.get("bombas")
    cant_velos=Player_1.items.get("velocidad")
    cant_escus=Player_1.items.get("escudo")
    bombas_tex = font0.render(f" x {cant_bombas}", False, "white")
    velo_text = font0.render(f" x {cant_velos}", False, "white")
    escu_text = font0.render(f" x {cant_escus}", False, "white")
    
    screen.blit(icono_habilidad, (7,30))


    screen.blit(pw_uso_1,(510,20))
    screen.blit(pw_uso_2,(550,0))
    
    screen.blit(bombas_img,(570,0))
    screen.blit (bombas_tex,(598,80))

    screen.blit(velocidad_img,(644,0))
    screen.blit (velo_text,(672,80))

    screen.blit(escudo_img,(718,0))
    screen.blit (escu_text,(746,80))

    screen.blit(texto_tiempo,(327,5))
    screen.blit(texto_puntaje_nivel,(332,25))
    #screen.blit(texto_puntaje_nivel, (425,5))

#Funcion que ha partir de la matriz lee las posiciones iniciales 
def save_positions(screen):
        global obstacles, matriz, Lista_Enemigos_1, obstacles_R
        for fil in range(len(matriz)):
             for col in range(len(matriz[fil])):
                  if matriz[fil][col] == '#': 
                       texture = Obstaculo_I
                       obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                       obstacles += [obs]
                       
                  if matriz[fil][col] == '*':
                       texture = Obstaculo_R
                       obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                       obstacles += [obs]
                       obstacles_R += [obs]

                  if matriz[fil][col] == 1:
                       Enemigo_perro = Enemigos(screen, (col*48), (fil*48), 1.1, spritesheet_perro_cañon, spritesheet_perro_muerte, 3, 48, 48, 1, 'black', False, random.randint(0,3))
                       Lista_Enemigos_1 += [Enemigo_perro]

#Este genera las texturas inamovibles, los enemigos se dibujan y se tratan dentro de su propia clase
def generate(screen):
        global obstacles, matriz
        for fil in range(len(matriz)):
             for col in range(len(matriz[fil])):
                  if matriz[fil][col] == '#': 
                       texture = Obstaculo_I
                       obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                       
                       obs.draw()
                  if matriz[fil][col] == '*':
                       texture = Obstaculo_R
                       obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                       obs.draw()
     
                  if matriz[fil][col] in (0,1,8,9,'u','d','l','r','w','a','s','f','c'):
                       if fil == 0 and col == 0:
                            texture = Floor_corner0
                            obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                            obs.draw()
                       elif fil == 0 and col == 16:
                            texture = Floor_corner3
                            obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                            obs.draw()
                       
                       elif fil == 10 and col == 16:
                            texture = Floor_corner2
                            obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                            obs.draw()
                        
                       elif fil == 10 and col == 0:
                            texture = Floor_corner1
                            obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                            obs.draw()

                       elif fil == 0:
                            texture = Floor_up
                            obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                            obs.draw()

                       elif col == 0:
                            texture = Floor_lside
                            obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                            obs.draw()
                        
                       elif col == 16: 
                            texture = Floor_rside
                            obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                            obs.draw()

                       elif fil == 10:
                            texture = Floor_down
                            obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                            obs.draw()
                        
                       else:
                            texture = Floor_nothing
                            obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                            obs.draw()

#funciones para la generacion y manejo de bombas
def bombastic_pos (screen): #guarda posicion de manejo de bombas 
     global lista_B, lista_E, bomba_in_bounds, lista_EL
     for fil in range(len(matriz)):
             for col in range(len(matriz[fil])):
                  if matriz[fil][col] == 8:
                       Bomba_R = Bomba_Matriz(screen, (col*48), (fil*48), spritesheet_Bomba, 5, 64, 64, 0.75, 'black',True)
                       lista_B += [Bomba_R]
                       matriz[fil][col] = 0
                  if matriz[fil][col] == 9:
                       Exp_R = Explosion_Matriz(screen, (col*48), (fil*48), spritesheet_exp_c, 5, 64, 64, 0.75, 'black',True)
                       lista_E += [Exp_R]
                       matriz[fil][col] = 0

                  if matriz[fil][col] in ('u','l','d','r'):
                       EXP_RL = Explosion_Matriz_Lados(screen, (col*48), (fil*48), spritesheet_exp_l, 5, 64, 64, 0.75, 'black',True,matriz[fil][col])
                       lista_EL += [EXP_RL]
                       

                  if matriz[fil][col] in ('w','a','s','f'):
                       EXP_RL = Explosion_Matriz_Lados(screen, (col*48), (fil*48), spritesheet_exp_b, 5, 64, 64, 0.75, 'black',True,matriz[fil][col])
                       lista_EL += [EXP_RL]

                  if matriz[fil][col] == 'c':
                       EXP_RL = Explosion_Matriz_Lados(screen, (col*48), (fil*48), spritesheet_exp_c, 5, 64, 64, 0.75, 'black',True,matriz[fil][col])
                       lista_EL += [EXP_RL]              
     if lista_B == []:
          bomba_in_bounds = False

def limpiar():
     global matriz
     for fil in range(len(matriz)):
             for col in range(len(matriz[fil])):
                       if matriz[fil][col] in ('u','l','d','r','w','a','s','f','c'):
                            matriz[fil][col] = 0
                       


def bombastic_hitbox ():
     global star_up, star_right, star_left, star_down
     for bomba in lista_B:
          bomba.auto_animate()
     for exp in lista_E:
          exp.auto_animate()
          for obsR in obstacles_R:
               if Explosion_Matriz.colisiona_con(exp, obsR):
                   matriz[int(obsR.y/48)][int(obsR.x/48)] = 0
                   obstacles_R.remove(obsR)
                   obstacles.remove(obsR)
          for enemies in Lista_Enemigos_1:
              if Explosion_Matriz.colisiona_con(exp, enemies):
                   enemies.animacion_muerte()
          
          
    
          x = exp.x // 48
          y = exp.y // 48
          max_filas = len(matriz)
          max_cols  = len(matriz[0])

          # ARRIBA
          
          for i in range(1, Fuerza_exp + 1):
               if not exp.star_up:
                    yi, xi = y - i, x
                    if not (0 <= yi < max_filas):
                         yi0 = y - (i - 1)
                         if 0 <= yi0 < max_filas:
                              if  yi0 != y:
                                   matriz[yi0][xi] = 'w'
                              else:
                                   matriz[yi0][xi] = 'c'
                         break

                    celda = matriz[yi][xi]
                    if celda == '*':
                         matriz[yi][xi] = 'u'
                         exp.star_up = True
                         
                         break
                    if celda in ('#', 9, 8):
                         break
                    matriz[yi][xi] = 'w' if i == Fuerza_exp else 'u'
               

          # ABAJO
          for i in range(1, Fuerza_exp + 1):
               if not exp.star_down:
                    yi, xi = y + i, x
                    if not (0 <= yi < max_filas):
                         yi0 = y + (i - 1)
                         if 0 <= yi0 < max_filas:
                              if yi0 != y:
                                   matriz[yi0][xi] = 's'
                              else:
                                   matriz[yi0][xi] = 'c'
                         break

                    celda = matriz[yi][xi]
                    if celda == '*':
                         matriz[yi][xi] = 'd'
                         exp.star_down = True
                         break
                    if celda in ('#', 9, 8):
                         break
                    matriz[yi][xi] = 's' if i == Fuerza_exp else 'd'

          # DERECHA
          for i in range(1, Fuerza_exp + 1):
               if not exp.star_right:
                    yi, xi = y, x + i
                    if not (0 <= xi < max_cols):
                         xi0 = x + (i - 1)
                         if 0 <= xi0 < max_cols:
                              if xi0 != x:
                                   matriz[yi][xi0] = 'f'
                              else:
                                   
                                   matriz[yi][xi0] = 'c'
                         break

                    celda = matriz[yi][xi]
                    if celda == '*':
                         matriz[yi][xi] = 'r'
                         exp.star_right = True
                         break
                    if celda in ('#', 9, 8):
                         break
                    matriz[yi][xi] = 'f' if i == Fuerza_exp else 'r'

          # IZQUIERDA
          for i in range(1, Fuerza_exp + 1):
               if not exp.star_left:
                    yi, xi = y, x - i
                    if not (0 <= xi < max_cols):
                         xi0 = x - (i - 1)
                         if 0 <= xi0 < max_cols:
                              if xi0 != x:
                                   matriz[yi][xi0] = 'a'
                              else:
                                   matriz[yi][xi0] = 'c'
                         break

                    celda = matriz[yi][xi]
                    if celda == '*':
                         matriz[yi][xi] = 'l'
                         exp.star_left = True
                         break
                    if celda in ('#', 9, 8):
                         break
                    matriz[yi][xi] = 'a' if i == Fuerza_exp else 'l'

     for exp_l in lista_EL:
          exp_l.auto_animate()
          matriz[exp_l.y//48][exp_l.x//48] = 0
          for obsR in obstacles_R:
               if Explosion_Matriz_Lados.colisiona_con(exp_l, obsR):
                   matriz[int(obsR.y/48)][int(obsR.x/48)] = 0
                   obstacles_R.remove(obsR)
                   obstacles.remove(obsR)
          for enemies in Lista_Enemigos_1:
              if Explosion_Matriz_Lados.colisiona_con(exp_l, enemies):
                   enemies.animacion_muerte()
          limpiar()
                 
     
#Funcion para leer la matriz de nivel
def leer_archivo(path):
        archivo = open(path, 'r')
        contenido = archivo.read()
        archivo.close()
        return contenido
def init (nivel):
        global matriz
        texto_nivel = f"Nivel_{nivel}.txt"
        matriz = eval(leer_archivo(texto_nivel))
init(nivel)

B_1 = Bomba(game_surface, 0, 0, spritesheet_Bomba, 5, 64, 64, 0.75, 'black',False) #Para la habilidad del tactico
E_1 = Explosion(game_surface, 0, 0, spritesheet_exp_c, 5, 64, 64, 0.75, 'black',False) #Para la habilidad del tactico
def pantalla_juego() : #ESTRO ES UN PLACEHOLDER PARA LA CLASE DE PANTALLA DE JUEGO  
    global matriz
    screen.fill("white")        
    dibujar_gui()
    game_surface.fill("black")  # Llama al método mover del jugador 1 para dibujarlo en la pantallag

    if primera_vez:
        save_positions(game_surface)
    
    generate(game_surface)
    bombastic_pos(game_surface)
    bombastic_hitbox()
    for ene_1 in Lista_Enemigos_1:
        ene_1.auto_move()
        #obstaculos funciona con la mascara de los obstaculos, asi pues para hacer colisiones solo ve si hay choque entre mascaras
        for obst in obstacles:
             if Enemigos.colisiona_con(ene_1, obst):
                # aquí ya chocaron
                ene_1.rebote()
    
    
    if B_1.bomba_animacion:
         B_1.auto_animate()
    if E_1.bomba_animacion:
         E_1.auto_animate()
         for obsR in obstacles_R:
              if Explosion.colisiona_con(E_1, obsR):
                   matriz[int(obsR.y/48)][int(obsR.x/48)] = 0
                   obstacles_R.remove(obsR)
                   obstacles.remove(obsR)
         for enemies in Lista_Enemigos_1:
              if Explosion.colisiona_con(E_1, enemies):
                   enemies.animacion_muerte()
                   
    Player_1.mover()
    Player_1.ejecutar_habilidad()          
    screen.blit(game_surface,(0, 100))  # Dibuja la superficie del juego en la pantalla

def pantalla_seleccion_jugador () : 
    global skin_seleccionada, skin_viendo, Player_1, prev_siguiente, prev_seleccion, estado, Player_1
    screen.fill("black")
    # Obtener el estado ACTUAL de los botones
    nuevo_viendo_actual = boton_siguiente_opcion.check_click()
    nuevo_seleccion_actual = boton_seleccionar.check_click()
    if nuevo_viendo_actual and not prev_siguiente:  # Solo en el flanco de subida
        skin_viendo += 1
    prev_siguiente = nuevo_viendo_actual  # Actualizar estado previo

    #PREVIEW DE JUGADOR 
    if skin_viendo > 2: 
        skin_viendo %=3
    if skin_viendo == 0:
        Titulo_skin= font1.render ("  Intangible", True, (198, 28, 232)) #texto que muestra el nombre de la skin")
         #dibuja el texto en la pantalla
        desc_skin = font0.render("'Es famoso porque nadie lo ve'", True, (255, 255, 255)) #texto que muestra la descripcion de la skin
        desc_skin2 = font0.render("     Habilidad especial: In-Tangible ", True, (69, 229, 222)) #texto que muestra la descripcion de la skin
        desc_skin3= font0.render("      Este mago conoce las artes oscuras.", True, (129, 133, 137))
        desc_skin4= font0.render("Su habilidad especial es que puede atravesar ", True, (129, 133, 137))
        desc_skin5= font0.render("           Paredes y enemigos con facilidad ", True, (129, 133, 137))
        preview= pg.transform.scale(preview_intangible, (200, 200)) #escala el preview del jugador intangible
    elif skin_viendo == 1:
        Titulo_skin= font1.render ("   Kamikaze", True, (248, 147, 18)) #texto que muestra el nombre de la skin")
        desc_skin = font0.render("      ' Un alma por una bomba '", True, (255, 255, 255)) #texto que muestra la descripcion de la skin
        desc_skin2 = font0.render("       Habilidad especial: Sacrifice ", True, (202, 28, 28)) #texto que muestra la descripcion de la skin
        desc_skin3= font0.render("Este comerciante conoce sus negocios.", True, (129, 133, 137))
        desc_skin4= font0.render("      Intercambia con los espiritus almas por ", True, (129, 133, 137))
        desc_skin5= font0.render("                       bombas y viceversa.", True, (129, 133, 137))
        preview = pg.transform.scale(preview_kamikaze, (200, 200)) #escala el preview del jugador kamikaze
    elif skin_viendo == 2:
        Titulo_skin= font1.render ("    Tactico", True, (127,169,7)) #texto que muestra el nombre de la skin")
        desc_skin = font0.render("    '   El hombre que calcula  '", True, (255, 255, 255)) #texto que muestra la descripcion de la skin
        desc_skin2 = font0.render("Habilidad especial: TACTICAL NUKE ", True, (32, 104, 0)) #texto que muestra la descripcion de la skin
        desc_skin3= font0.render("          El famosisimo Beremiz Samir, que ", True, (129, 133, 137))
        desc_skin4= font0.render("tocado por la guerra fue. Su habilidad le permite", True, (129, 133, 137))
        desc_skin5= font0.render("calcular un misil en donde sus enemigos estan ", True, (129, 133, 137))
        preview = pg.transform.scale(preview_tactico, (200, 200))
    #SELECCION DE JUGADOR 
    if nuevo_seleccion_actual and not prev_seleccion:  # Solo en el flanco de subida
        skin_seleccionada = prev_seleccion
        skin_seleccionada = skin_viendo
        if skin_seleccionada == 0 : 
            Player_1= Jugador_1(game_surface,0,0,4,spritesheet_idle_int,spritesheet_habilidad_int,9,32,32,1.5,"black","Invencible",6,(3, 240, 252),"yellow") #GENERAR PLAYER INVENCIBLE
        elif skin_seleccionada == 1 : 
            Player_1= Jugador_1(game_surface,0,0,4,spritesheet_idle_kam,spritesheet_habilidad_kam,8,31,54,1,"black","Kamikaze",6,(3, 240, 252),"yellow")    #GENERAR PLAYER KAMIKAZE
        elif skin_seleccionada == 2 :
            Player_1= Jugador_1(game_surface,0,0,4,spritesheet_idle_tac,spritesheet_habilidad_tac,3,96,96,0.7,"black","Tactico",6,(3, 240, 252),"yellow")   #GENERAR PLAYER TACTICO
        
        estado ="juego" #SIEMPRE BAMCIAR EL ESTADO AML SIGUIENTE ANTES DE JUEGO O NO SE 
    prev_seleccion = nuevo_seleccion_actual  # Actualizar estado previo 
 
    screen.blit(Titulo_skin, (300, 50))
    screen.blit(desc_skin, (257, 100))  # Dibuja la descripción de la skin en la pantalla
    screen.blit(desc_skin2, (235, 360))  # Dibuja la descripción de la skin en la pantalla
    screen.blit(desc_skin3, (200, 400))  # Dibuja la descripción de la skin en la pantalla
    screen.blit(desc_skin4, (175, 420))  # Dibuja la descripción de la skin en la pantalla
    screen.blit(desc_skin5, (190, 440))  # Dibuja la descripción de la skin en la pantalla
    screen.blit(preview, (290, 135))  # Dibuja el preview del jugador en la pantalla




    boton_siguiente_opcion.draw(screen)  # Dibuja el botón en la pantalla
    boton_seleccionar.draw(screen)  # Dibuja el botón en la pantalla

tiempo_juego.start()
while True:
#cambiador de estado
    if estado == "juego":  # Si el estado es "juego", se muestra la pantalla de juego
        tiempo_juego.reanudar()
        pantalla_juego()
        primera_vez = False

    elif estado == "seleccion_personaje":  # Si el estado es "creacion_niveles", se muestra la pantalla de creación de niveles
        pantalla_seleccion_jugador()
    elif estado=="menu" : 
        pantalla_titulo()
    for event in pg.event.get():
        if event.type == pg.QUIT:
            tiempo_juego.detener()
            pg.quit()
            sys.exit()

        if event.type == pg.MOUSEBUTTONDOWN:
             mouse_pos = pg.mouse.get_pos()
             if 0 < mouse_pos[0] < 816 and 100 < mouse_pos[1] < 628:
               #B_1 = Bomba(game_surface, mouse_pos[0]-32, mouse_pos[1]-132, spritesheet_Bomba, 5, 64, 64, 0.75, 'black',True)
               #E_1 = Explosion(game_surface, mouse_pos[0]-88, mouse_pos[1]-200, spritesheet_exp_c, 4, 64, 64, 3, 'black',False)
               
               if 0 <= mouse_pos[0]//48 < 17 and 0 <= mouse_pos[1]//48 < 13:
                    if matriz[(mouse_pos[1]-100)//48][(mouse_pos[0]//48)] not in ('#','*'):
                         matriz[(mouse_pos[1]-100)//48][(mouse_pos[0]//48)] = 8
                    bomba_in_bounds = True  

    pg.display.flip()
    reloj.tick(60)


#TODO : benja
#cambiar powerups para aferctar varas del player
#agregar healthbar de boss
#agregar puntaje 
