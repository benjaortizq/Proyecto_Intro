#                   PROYECTO DE BOMBERMAN 
#                  BENJAMIN ORTIZ 2025064599
#                  STEADMAN MURILLO 2025097768
#           IC-1802 INTRODUCCION A LA PROGRAMACION 
#                     I SEMESTRE DE 2025
import time as t
import threading as th
import random 
import sys 
import json
import pygame as pg
from pygame import mixer 
import math

#pinche benja
#Aqui epiezan las clases del juego  
#----------------------------------------------------------CLASES UTILES DE PYGAME---------------------------------------
class Reloj(th.Thread):
    def __init__(self, tiempo_inicial):
        super().__init__()
        self.tiempo = tiempo_inicial
        self.en_marcha = True
        self.isDaemon = False  # Para que el hilo se cierre con el programa principal
        self.pausado = False
        self.lock = th.Lock()  # Para sincronización
        
    def run(self):
        while self.en_marcha and self.tiempo > 0:
            with self.lock:
                if not self.pausado:
                    t.sleep(0.85)  # soy un ijueputa
                    self.tiempo -= 1
                    
    def detener(self):
        self.en_marcha = False
        
    def pausar(self):
        self.pausado = True
        
    def reanudar(self):
        self.pausado = False

# Clase SpriteSheet: Carga una hoja de sprites y permite obtener imágenes individuales.
class SpriteSheet (): 
    def __init__(self, image): 
        self.sheet = image  # Carga la imagen de la hoja de sprites
    
    def get_image(self, frame, width, height, scale, colour):
        image = pg.Surface((width, height)).convert_alpha()     # Crea una superficie para el frame
        image.blit(self.sheet, (0, 0), ((frame * width), 0, width, height))  # Copia el frame correspondiente de la hoja de sprites
        image = pg.transform.scale(image, (width * scale, height * scale))  # Escala la imagen al tamaño deseado
        image.set_colorkey(colour)      # Establece el color clave para hacer transparente el fondo

        return image
#CLASE BOTON: Representa un botón en la interfaz del juego.
class Boton : 
    def __init__(self, x, y, width, height, text, font,size, color, hover_color ):    # '"ALERTA  : EN FONT TIENE QUE RECIBIR LA STRING DE LA DIRECCION DE LA FUENTE, POR EJEMPLO "fonts/arial.ttf"'
        self.rect = pg.Rect(x, y, width, height)  # Crea un rectángulo para el botón
        self.text = text  # Texto del botón
        self.font = pg.font.Font(font,size)  # Fuente del texto
        self.color = color 
        self.size = size # Color normal del botón
        self.hover_color = hover_color  # Color al pasar el mouse sobre el botón
        self.last_mouse_state  = None   # Tipo de acción (por ejemplo, cambiar de estado)
    def check_click(self):
        mouse_pos = pg.mouse.get_pos()
        mouse_pressed = pg.mouse.get_pressed()[0]
        # Detectar solo el momento exacto cuando se presiona el botón  
        if self.rect.collidepoint(mouse_pos):
            if mouse_pressed and not self.last_mouse_state:  # Solo en el frame del clic inicial
                return True  # Retorna True si el botón fue presionado
            return False
        return False

    def draw(self, surface):
        mouse_pos = pg.mouse.get_pos()  # Obtiene la posición del mouse
        if self.rect.collidepoint(mouse_pos):  # Verifica si el mouse está sobre el botón
            pg.draw.rect(surface, self.hover_color, self.rect,int(self.size*0.55),int(self.size*0.2))  # Dibuja el botón con el color de hover
        else:
            pg.draw.rect(surface, self.color, self.rect,int(self.size*0.55),int(self.size*0.2))  # Dibuja el botón con el color normal
          # Establece el tamaño de la fuente
        text_surface = self.font.render(self.text, True, (255, 255, 255))  # Renderiza el texto del botón
        text_rect = text_surface.get_rect(center=self.rect.center)  # Centra el texto en el botón
        surface.blit(text_surface, text_rect)  # Dibuja el texto en la superficie

class HealthBar:
    def __init__(self, x, y, width, height, hp, max_hp, color_f,color_h):
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.hp = hp  # Salud actual del jugador
        self.max_hp = max_hp  # Salud máxima del jugador
        self.color_f = color_f
        self.color_h = color_h  # Color de la barra de salud    
    def draw(self, surface):
        ratio = self.hp / self.max_hp  # Calcula la proporción de salud actual respecto a la máxima
        pg.draw.rect(surface, self.color_f, (self.x, self.y, self.width, self.height))  # Dibuja el fondo de la barra de salud
        pg.draw.rect(surface, self.color_h, (self.x, self.y, self.width * ratio, self.height))

class Healthbar_Player (HealthBar) :
    def __init__(self, x, y, width, height, hp, max_hp, heart_texture, cant_vidas, font):
        super().__init__(x, y, width, height, hp, max_hp, (255, 0, 0), (0, 255, 0))  # Llama al constructor de HealthBar con colores por defecto
        self.heart_texture = heart_texture  # Textura del corazón para la barra de salud
        self.cant_vidas = cant_vidas  # Cantidad de vidas del jugador
        self.font = font  # Fuente para mostrar la cantidad de vidas
    def draw_atributes(self, surface):
        surface.blit(self.heart_texture, (self.x - heart_texture.get_width()-3, self.y-5))  # Dibuja el corazón en la barra de salud
        vidas=self.font.render (f"x {self.cant_vidas}", True, (255, 255, 255)) # Renderiza la cantidad de vidas del jugador
        surface.blit(vidas, (self.x - heart_texture.get_width()-32, self.y+5))  # Dibuja la cantidad de vidas en la barra de salud

# -------------------------------------------------------CLASES DEL JUEGO-------------------------------------------
# Clase Jugador: Representa al jugador en el juego.

class Jugador : 
    def __init__(self, area_juego, pos_x, pos_y, velocidad, sps_idle,sps_mover,sps_hab,sps_muerte, frames_idle,frames_mover,frames_hab, frames_muerte, frame_w,frame_h, scale, colour): 
        self.area_juego = area_juego #superficie del juego donde se dibuja el jugador
        self.x = pos_x
        self.y = pos_y
        self.velocidad = velocidad              #velocidad del jugador
        self.states = {  
            "idle": (sps_idle, frames_idle),
            "mover": (sps_mover, frames_mover),
            "hab":   (sps_hab,   frames_hab),
            "muerte":(sps_muerte,frames_muerte),
        }
        self.width_frame = frame_w
        self.height_frame = frame_h   #esto siempre es estatico. como las spritesheets son horizontales entonces esto que qeuda asi . 
        self.scale = scale       
        self.frames_muerte=frames_muerte                       #multiplicador de escala para el sprite
        self.colour = colour                  #color de fondo del sprite que se va a eliminar  
        self.state = "idle"
        self.current_spritesheet, self.frame_count = self.states[self.state]
        self.current_frame  = 0
        self.last_update    = t.time()
        self.last_move_time = t.time() 
        self.current_skin = self.current_spritesheet.get_image(0, 32, 32, scale, colour)
        self.mask= pg.mask.from_surface(self.current_skin)  # Crea una máscara del sprite actual para colisiones
        self.muerto=False
        self.can_always_move=False
        self.facing_left = False 
        
    def set_state(self, new_state):
        
        if new_state == self.state:
            return
        self.state = new_state
        self.current_spritesheet, self.frame_count = self.states[new_state]
        self.current_frame  = 0
        self.last_update    = t.time()
 #reinicia el tiempo de la ultima actualizacion para que no se salte frames al cambiar de spritesheet
    
    def animacion_skin(self) : 
      now = t.time()
      if now - self.last_update > 0.1:
           self.last_update  = now
           self.current_frame = (self.current_frame + 1) % self.frame_count
      img=self.current_spritesheet.get_image(self.current_frame,self.width_frame,self.height_frame,self.scale,self.colour)
      if self.facing_left : 
           img=pg.transform.flip(img,True,False) 
      img.set_colorkey (self.colour)
      self.current_skin = img
      self.mask = pg.mask.from_surface(self.current_skin)
          
    def colisiona_con(self, otro_objeto):
        # Calcular diferencia de posiciones (offset)
        offset_x = int(otro_objeto.x) - int(self.x)
        offset_y = int(otro_objeto.y) - int(self.y)
        return self.mask.overlap(otro_objeto.mask, (offset_x, offset_y)) is not None
    
    def mover(self, obstacles):
          now=t.time()
          global obstacles_R
          keys = pg.key.get_pressed()
          dx = (keys[pg.K_d] - keys[pg.K_a]) * self.velocidad
          dy = (keys[pg.K_s]  - keys[pg.K_w])   * self.velocidad
          if dx < 0 : 
               self.facing_left = True 
          else: 
               self.facing_left = False 
          if dx != 0 or dy != 0:
            self.last_move_time = now

          # Calcular nueva posición
          nueva_x = self.x + dx
          nueva_y = self.y + dy
          max_x = self.area_juego.get_width()  -40
          max_y = self.area_juego.get_height() -40
          nueva_x = max(0, min(nueva_x, max_x))
          nueva_y = max(0, min(nueva_y, max_y))


          # Verificar si habría colisión en la nueva posición
          if self.can_always_move : 
               candidatos = [o for o in obstacles if o not in obstacles_R]
          else: 
               candidatos = obstacles
          colision = False
          for obst in candidatos :
               offset_x = int(obst.x - nueva_x)
               offset_y = int(obst.y - nueva_y)
               if self.mask.overlap(obst.mask, (offset_x, offset_y)):
                    colision = True
                    break
          else : 
               colision= False
          # Si no hay colisión, actualiza posición
          if not colision:
               self.x = nueva_x
               self.y = nueva_y
          self.ejecutar_habilidad()
          if self.ejecutando_habilidad:
               self.set_state("hab")
          else:
               if hasattr(self, "muerto") and self.muerto:
                    self.set_state("muerte")
               elif dx != 0 or dy != 0:
                    self.set_state("mover")
               elif now - self.last_move_time > 0.2:
                    self.set_state("idle")


          self.animacion_skin()

          # Siempre se dibuja
          self.area_juego.blit(self.current_skin, (self.x, self.y))
class Jugador_1(Jugador): #clase hija de jugador, que hereda de la clase padre
    def __init__(self, area_juego, pos_x, pos_y, velocidad,sps_idle,sps_mover,sps_hab,sps_muerte, frames_idle,frames_mover,frames_hab, frames_muerte, frame_w,frame_h, scale, colour,habilidad, cant_vidas,color_habilidad, color_bajada ):
        super().__init__( area_juego, pos_x, pos_y, velocidad, sps_idle,sps_mover,sps_hab,sps_muerte, frames_idle,frames_mover,frames_hab, frames_muerte, frame_w,frame_h, scale, colour)
        self.habilidad=habilidad
        self.vida=100 #vida del jugador
        self.vida_max_actual=100
        self.vida_maxima=200 if habilidad=="Kamikaze" else 150 if habilidad=="Invencible" else 250 if habilidad=="Tactico" else 100
        self.puntos_compra=0
        self.ejecutando_habilidad = False
        self.tiempo_inicio_habilidad = 0
        self.max_tiempo_habilidad = 5  # 5 segundos máximo
        self.cant_vidas = cant_vidas  # Cantidad de vidas del jugador
        self.color_habilidad = color_habilidad  # Color de la habilidad
        self.color_subiendo =color_habilidad
        self.barra_habilidad = 0  # Tiempo de recarga de la habilidad
        self.color_bajada=color_bajada
        self.powerups= {"dano" : 0 , "vida":0}
        self.items = {"bombas":50, "velocidad" : 0 ,"escudo":0 }
        self.powerup_en_uso={"dano": False, "vida": False}
        self.item_en_uso={"bombas":False, "velocidad" : False ,"escudo":False }
        self.tiene_llave=False
        self.ultima_bomba=0
        self.base_speed = self.velocidad      # ejemplo
        self.speed = self.base_speed
        self.defensa_activa = False
        

    def ejecutar_habilidad(self ) :
        keys = pg.key.get_pressed()
        current_time = t.time()
        global escojio
        # Iniciar habilidad al presionar espacio
        if keys[pg.K_SPACE] and not self.ejecutando_habilidad and self.barra_habilidad >50:
            self.ejecutando_habilidad = True
            self.tiempo_inicio_habilidad = current_time
            self.set_state("hab")
            #print(f"Iniciando habilidad: {self.habilidad}")
        if keys[pg.K_n] and self.items["velocidad"] > 0 and not self.item_en_uso["velocidad"]:
            self.item_en_uso["velocidad"] = True
            self.ultimo_velocidad = current_time
            self.items["velocidad"] -= 1
            # Aumentá el atributo de velocidad (asumiendo que tenés self.speed y self.base_speed)
            self.velocidad = self.base_speed * 1.5
        if keys[pg.K_m] and self.items["escudo"] > 0 and not self.item_en_uso["escudo"]:
            self.item_en_uso["escudo"] = True
            self.ultimo_escudo = current_time
            self.items["escudo"] -= 1
            # Activás la bandera de defensa
            self.defensa_activa = True
        if self.item_en_uso["velocidad"]:
            if current_time - self.ultimo_velocidad > 5:
                self.item_en_uso["velocidad"] = False
                self.velocidad = self.base_speed  # volvés a la velocidad normal

        # Escudo: 3 segundos
        if self.item_en_uso["escudo"]:
            self.vida = min(self.vida + 0.025, self.vida_max_actual)  # Recuperás vida al usar el escudo
            if current_time - self.ultimo_escudo > 3:
                self.item_en_uso["escudo"] = False
                self.defensa_activa = False  # desactivás la defensa
        
        # Detener si pasa el tiempo máximo
        if self.ejecutando_habilidad:
            tiempo_transcurrido = current_time - self.tiempo_inicio_habilidad
            self.barra_habilidad -=0.5 if self.barra_habilidad >= 1 else self.barra_habilidad==1
            self.color_habilidad = self.color_bajada
            if self.habilidad=="Invencible" : 
                 self.can_always_move=True
            elif self.habilidad=="Kamikaze" :
                 pantalla_habilidad_kam()
            if tiempo_transcurrido > self.max_tiempo_habilidad or int(self.barra_habilidad)==0:
                self.ejecutando_habilidad = False
                self.can_always_move=False
                escojio = False
                self.set_state("idle")
                #print("Habilidad detenida por tiempo máximo")

        if not self.ejecutando_habilidad:
            self.color_habilidad=self.color_subiendo
            self.barra_habilidad = min(self.barra_habilidad + 0.1, 100)   #ni idea porque co 99 sirve pero con ese numero me deja la barra en 100 maximo xd  
    def usar_bomba(self):
             global matriz
             tiempo_actual=t.time()
             if self.items.get("bombas") > 0:
                 keys = pg.key.get_pressed()
                 if keys[pg.K_b] and tiempo_actual-self.ultima_bomba>=0.5:
                     centro_x = self.x + 16
                     centro_y = self.y + 16
                     col = int(centro_x // 48)
                     fila = int(centro_y // 48 )                      
                     Bomba_R = Bomba_Matriz(self.area_juego, (self.x+16) ,(self.y+16), spritesheet_Bomba, 5, 64, 64, 0.75, 'black', True)
                     lista_B.append(Bomba_R)
                     


                     matriz[fila][col] = 0 #if matriz[(self.y+24) // 48][(self.x+24) // 48] = *  
                     self.items["bombas"] -= 1
                     #print(f"Jugador en píxeles: ({self.x},{self.y})  →  celda: ({fila},{col})")
                     self.ultima_bomba = tiempo_actual

#ocupo tipo scar tiempo. si en 0,5s no se presiona ninguna tecla entonces el sprote es el statico, si en n se presiona deacruerdo al movimiento cambia el sprite. sis e presiona el de habiliad, entones se muestra el speiret habilidad.
#_____________________________________________________________________________________________________
#CLASES DE LA MATRIZ O ENEMIGOS
#Clase Obstaculo 
class Obstaculo:
    def __init__(self, screen, x, y, texture):
        self.screen = screen
        self.x = x
        self.y = y
        self.texture = texture
        self.mask    = pg.mask.from_surface(self.texture)
        self.rect = self.texture.get_rect(topleft=(self.x, self.y))
        
    def draw(self):
        self.screen.blit(self.texture, (self.x, self.y))

    def colisiona_con(self, otro_objeto):
     # Calcular diferencia de posiciones (offset)
     offset_x = int(otro_objeto.x) - int(self.x)
     offset_y = int(otro_objeto.y) - int(self.y)
     return self.mask.overlap(otro_objeto.mask, (offset_x, offset_y)) is not None

class Trampa:
    def __init__(self, screen, x, y, texture, frame_count, frame_w,frame_h, scale, colour):
        self.screen = screen
        self.x = x
        self.y = y
        
        self.current_spritesheet = texture
        self.frame_count = frame_count          #CAANTIDAD DE FRAMES DE LA SKIN DEL JUGAODR
        self.width_frame = frame_w
        self.height_frame = frame_h   #esto siempre es estatico. como las spritesheets son horizontales entonces esto que qeuda asi . 
        self.scale = scale                              #multiplicador de escala para el sprite
        self.colour = colour                  #color de fondo del sprite que se va a eliminar
        self.last_update = t.time()     #tiempo de la ultima actualizacion del frame
        self.current_frame = 0        #numero de frame que esta actualmente dibujandose.
        self.current_skin = self.current_spritesheet.get_image(0, 48, 48, self.scale, self.colour)
        self.mask= pg.mask.from_surface(self.current_skin)
        self.activo = False
        
    
    def animation(self):
         self.animacion_skin()
         self.screen.blit(self.current_skin, (self.x, self.y))
    def colisiona_con(self, otro_objeto):
     # Calcular diferencia de posiciones (offset)
     offset_x = int(otro_objeto.x) - int(self.x)
     offset_y = int(otro_objeto.y) - int(self.y)
     return self.mask.overlap(otro_objeto.mask, (offset_x, offset_y)) is not None
    
    def animacion_skin(self) : 
        current_time = t.time()
        if current_time - self.last_update > 0.1 : # Cambio de frame cada 0.2 segundos
               self.last_update = current_time
               self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
        self.current_skin = self.current_spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)
        self.mask = pg.mask.from_surface(self.current_skin)
        if self.current_frame in (8,9,10,11):
             self.activo = True
        else:
             self.activo = False

class Hielo(Obstaculo):
     def __init__(self, screen, x, y, texture):
          super().__init__(screen, x, y, texture)
#Class Enemigos
#Variable globales enemigos
def tiene_linea_vision(origen, destino, obstaculos):
    ray = pg.Rect(0, 0, 1, 1)
    pasos = int(distance(origen, destino))
    for i in range(pasos):
        x = origen[0] + (destino[0] - origen[0]) * (i / pasos)
        y = origen[1] + (destino[1] - origen[1]) * (i / pasos)
        ray.center = (x, y)
        for obs in obstaculos:
            
            if ray.colliderect(obs.rect):
                return False
    return True


def distance(p1, p2):
    return math.hypot(p2[0] - p1[0], p2[1] - p1[1])




#Screen = area_juego
class Enemigos:
     def __init__(self, screen, x, y, velocidad, spritesheet_walk, spritesheet_death, frame_count, frame_w,frame_h, scale, colour, muerte,dir):
          self.screen = screen
          self.x = x
          self.y = y
          self.velocidad = velocidad
          self.current_spritesheet = spritesheet_walk
          self.frame_count = frame_count          #CAANTIDAD DE FRAMES DE LA SKIN DEL JUGAODR
          self.width_frame = frame_w
          self.height_frame = frame_h   #esto siempre es estatico. como las spritesheets son horizontales entonces esto que qeuda asi . 
          self.scale = scale                              #multiplicador de escala para el sprite
          self.colour = colour                  #color de fondo del sprite que se va a eliminar
          self.last_update = t.time()     #tiempo de la ultima actualizacion del frame
          self.current_frame = 0        #numero de frame que esta actualmente dibujandose.
          self.current_skin = self.current_spritesheet.get_image(0, 48, 48, self.scale, self.colour)
          self.mask= pg.mask.from_surface(self.current_skin)
          self.dir = dir
          self.spritesheet_death = spritesheet_death
          self.muerte = muerte
          
     def colisiona_en_posicion(self, x, y, lista_obstaculos):
          temp_mask = pg.mask.from_surface(self.current_skin)
          for obs in lista_obstaculos:
               offset_x = int(obs.x - x)
               offset_y = int(obs.y - y)
               if temp_mask.overlap(obs.mask, (offset_x, offset_y)):
                    return True
          return False
     
     def puede_ver_jugador(self, jugador_pos, obstáculos, vision_radio=400):
          enemigo_pos = (self.x + self.current_skin.get_width() // 2,
                         self.y + self.current_skin.get_height() // 2)
          
          if distance(enemigo_pos, jugador_pos) <= vision_radio:
               return tiene_linea_vision(enemigo_pos, jugador_pos, obstáculos)
          return False

     

     def perseguir_jugador(self, jugador_pos, lista_obstaculos):
          self.animacion_skin()

          dx = jugador_pos[0] - self.x
          dy = jugador_pos[1] - self.y
          dist = math.hypot(dx, dy)
          if dist == 0:
               return

          dx_unit = dx / dist
          dy_unit = dy / dist

          se_movio = False

          # Intentar mover en X
          nuevo_x = self.x + dx_unit * self.velocidad
          if not self.colisiona_en_posicion(nuevo_x, self.y, lista_obstaculos):
               self.x = nuevo_x
               se_movio = True

          # Intentar mover en Y
          nuevo_y = self.y + dy_unit * self.velocidad
          if not self.colisiona_en_posicion(self.x, nuevo_y, lista_obstaculos):
               self.y = nuevo_y
               se_movio = True

          # Si no pudo moverse, intentar desplazamiento lateral (evitación simple)
          if not se_movio:
               # Probar movimientos alternos pequeños (tipo "temblor" o "búsqueda")
               for offset in [-8, 8, -16, 16]:
                    if not self.colisiona_en_posicion(self.x + offset, self.y, lista_obstaculos):
                         self.x += offset
                         break
                    elif not self.colisiona_en_posicion(self.x, self.y + offset, lista_obstaculos):
                         self.y += offset
                         break

          self.screen.blit(self.current_skin, (self.x, self.y))




     def animacion_muerte(self):
          self.cambiar_spritesheet(self.spritesheet_death)
          self.muerte = True
          self.velocidad = 0
          self.animacion_skin()
 
    #line_of_sight
     def move(self):
        self.animacion_skin()
        # HORIZONTAL: dir 0 ← , dir 1 →
        if self.dir in (0, 1):
            
            dx = -self.velocidad if self.dir == 0 else self.velocidad
            new_x = self.x + dx
            if dx < 0:
                 self.current_skin = pg.transform.flip(self.current_skin, True, False)
                 self.current_skin.set_colorkey('black')

            if new_x <= 0:
                 self.dir = 1
            if new_x >= 770:
                 self.dir = 0
            # límites de pantalla
            if 0 < new_x < 770:
                self.x = new_x
        # VERTICAL: dir 2 ↑ , dir 3 ↓
        elif self.dir in (2, 3):
            dy = -self.velocidad if self.dir == 2 else self.velocidad
            new_y = self.y + dy
            if new_y <= 0:
                 self.dir = 3
            if new_y >= 480:
                 self.dir = 2
            if 0 < new_y < 480:
                self.y = new_y

        # Dibujo
        self.screen.blit(self.current_skin, (self.x, self.y))

     def auto_move(self):
                    self.move()
     
     def move_darkness(self):
        self.animacion_skin()
        # HORIZONTAL: dir 0 ← , dir 1 →
        if self.dir in (0, 1):
            
            dx = -self.velocidad if self.dir == 0 else self.velocidad
            new_x = self.x + dx
            if dx < 0:
                 self.current_skin = pg.transform.flip(self.current_skin, True, False)
                 self.current_skin.set_colorkey('black')

            if new_x <= 0:
                 self.dir = 1
            if new_x >= 770:
                 self.dir = 0
            # límites de pantalla
            if 0 < new_x < 770:
                self.x = new_x
        # VERTICAL: dir 2 ↑ , dir 3 ↓
        elif self.dir in (2, 3):
            dy = -self.velocidad if self.dir == 2 else self.velocidad
            new_y = self.y + dy
            if new_y <= 0:
                 self.dir = 3
            if new_y >= 480:
                 self.dir = 2
            if 0 < new_y < 480:
                self.y = new_y

     def draw(self):
          self.screen.blit(self.current_skin, (self.x, self.y))

     def rebote(self):
          #solo rebota su hay una pared
          self.dir ^= 1          

     def cambiar_spritesheet(self, nuevo_spritesheet): #esto es para cambiar la spritesheet del jugador, por ejemplo cuando se ejecuta una habilidad
          self.current_spritesheet = nuevo_spritesheet #cambia el spritesheet actual al nuevo
          self.current_frame = 0  #reinicia el frame actual a 0
          self.last_update = t.time()     #reinicia el tiempo de la ultima actualizacion para que no se salte frames al cambiar de spritesheet
    
     def animacion_skin(self) : 
        current_time = t.time()
        if self.muerte:
             if current_time - self.last_update > 0.5 : # Cambio de frame cada 0.2 segundos
                    self.last_update = current_time
                    self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
             self.current_skin = self.current_spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)
             self.mask = pg.mask.from_surface(self.current_skin)
             if self.current_frame == 2:
                Lista_Enemigos_1.remove(self)
                  
        else:
          if current_time - self.last_update > 0.1 : # Cambio de frame cada 0.2 segundos
               self.last_update = current_time
               self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
          self.current_skin = self.current_spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)
          self.mask = pg.mask.from_surface(self.current_skin)
    
     def colisiona_con(self, otro_objeto):
        # Calcular diferencia de posiciones (offset)
        offset_x = int(otro_objeto.x) - int(self.x)
        offset_y = int(otro_objeto.y) - int(self.y)
        return self.mask.overlap(otro_objeto.mask, (offset_x, offset_y)) is not None

#Enemigo 2
class Enemigo2 (Enemigos):
     def __init__(self, screen, x, y, velocidad, spritesheet_walk, spritesheet_death, spritehurt, frame_count, frame_w, frame_h, scale, colour, muerte, dir, vida):
          super().__init__(screen, x, y, velocidad, spritesheet_walk, spritesheet_death, frame_count, frame_w, frame_h, scale, colour, muerte, dir)
          self.spritesheet_walk = spritesheet_walk
          self.spritehurt = spritehurt
          self.vida = vida
          self.hurt = False

     def move(self, cambio_prob=0.005):  # 0.5% probabilidad de cambio
          self.animacion_skin()

          # Cambio aleatorio de dirección con baja probabilidad
          if random.random() < cambio_prob:
               reversa = {0: 1, 1: 0, 2: 3, 3: 2}
               posibles = [0, 1, 2, 3]
               posibles.remove(reversa[self.dir])  # evitar reversa inmediata
               self.dir = random.choice(posibles)

          # Movimiento HORIZONTAL
          if self.dir in (0, 1):
               dx = -self.velocidad if self.dir == 0 else self.velocidad
               new_x = self.x + dx

               if dx < 0:
                    self.current_skin = pg.transform.flip(self.current_skin, True, False)
                    self.current_skin.set_colorkey('black')

               if new_x <= 0:
                    self.dir = 1
               elif new_x >= 770:
                    self.dir = 0
               elif 0 < new_x < 770:
                    self.x = new_x

          # Movimiento VERTICAL
          elif self.dir in (2, 3):
               dy = -self.velocidad if self.dir == 2 else self.velocidad
               new_y = self.y + dy

               if new_y <= 0:
                    self.dir = 3
               elif new_y >= 480:
                    self.dir = 2
               elif 0 < new_y < 480:
                    self.y = new_y

          # Dibujo
          self.screen.blit(self.current_skin, (self.x, self.y))

     def animacion_hurt(self):
          self.cambiar_spritesheet(self.spritehurt)
          self.velocidad = 1.5
          self.hurt = True
          self.animacion_skin()

     def animacion_skin(self) : 
        current_time = t.time()
        if self.muerte:
             if current_time - self.last_update > 0.5 : # Cambio de frame cada 0.2 segundos
                    self.last_update = current_time
                    self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
             self.current_skin = self.current_spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)
             self.mask = pg.mask.from_surface(self.current_skin)
             if self.current_frame == 2:
                Lista_Enemigos_2.remove(self)
        if self.hurt:
             if current_time - self.last_update > 1 : # Cambio de frame cada 0.2 segundos
                    self.last_update = current_time
                    self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
             self.current_skin = self.current_spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)
             self.mask = pg.mask.from_surface(self.current_skin)
             if self.current_frame == 1:
                self.hurt = False
                self.vida -= 1
                self.cambiar_spritesheet(self.spritesheet_walk)
                if self.vida <= 0:
                     self.muerte = True
                     self.cambiar_spritesheet(self.spritesheet_death)
                
        else:
          if current_time - self.last_update > 0.1 : # Cambio de frame cada 0.2 segundos
               self.last_update = current_time
               self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
          self.current_skin = self.current_spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)
          self.mask = pg.mask.from_surface(self.current_skin)

#Enemigo 3
class Enemigo3 (Enemigo2):
     def __init__(self, screen, x, y, velocidad, spritesheet_walk, spritesheet_death, sprite_attack, spritehurt, frame_count, frame_w, frame_h, scale, colour, muerte, dir, vida):
          super().__init__(screen, x, y, velocidad, spritesheet_walk, spritesheet_death, spritehurt, frame_count, frame_w, frame_h, scale, colour, muerte, dir, vida)
          self.sprite_attack = sprite_attack
          self.attack = False
          self.attack_frame_inicial = False
          self.original_velocidad = velocidad
          self.laser = None
          self.laser_dibujado = False
          

     def move(self, cambio_prob=0.05):  # 0.5% probabilidad de cambio
          self.animacion_skin()

          # Cambio aleatorio de dirección con baja probabilidad
          if random.random() < cambio_prob:
               reversa = {0: 1, 1: 0, 2: 3, 3: 2}
               posibles = [0, 1, 2, 3]
               posibles.remove(reversa[self.dir])  # evitar reversa inmediata
               self.dir = random.choice(posibles)

          # Movimiento HORIZONTAL
          if self.dir in (0, 1):
               dx = -self.velocidad if self.dir == 0 else self.velocidad
               new_x = self.x + dx

               if dx < 0:
                    self.current_skin = pg.transform.flip(self.current_skin, True, False)
                    self.current_skin.set_colorkey('black')

               if new_x <= 0:
                    self.dir = 1
               elif new_x >= 770:
                    self.dir = 0
               elif 0 < new_x < 770:
                    self.x = new_x

          # Movimiento VERTICAL
          elif self.dir in (2, 3):
               dy = -self.velocidad if self.dir == 2 else self.velocidad
               new_y = self.y + dy

               if new_y <= 0:
                    self.dir = 3
               elif new_y >= 480:
                    self.dir = 2
               elif 0 < new_y < 480:
                    self.y = new_y

          # Dibujo
          

     def animacion_attack(self, jugador_pos):

          if not self.attack:
               self.attack = True
               self.attack_frame_inicial = True
               self.cambiar_spritesheet(self.sprite_attack)
               self.velocidad = 0

               dx = jugador_pos[0] - self.x
               dy = jugador_pos[1] - self.y

               if abs(dx) > abs(dy):
                    self.dir_ataque = 'izq' if dx < 0 else 'der'
                    self.direccion_visual = self.dir_ataque
               else:
                    self.dir_ataque = 'arr' if dy < 0 else 'aba'
                    self.direccion_visual = self.dir_ataque




     def animacion_skin(self):
          current_time = t.time()

          if self.muerte:
               self.frame_count = 7
               if current_time - self.last_update > 0.3:
                    self.last_update = current_time
                    self.current_frame = (self.current_frame + 1) % self.frame_count
               self.current_skin = self.current_spritesheet.get_image(
                    self.current_frame, self.width_frame, self.height_frame, self.scale, self.colour)
               self.mask = pg.mask.from_surface(self.current_skin)
               if self.current_frame == 6:
                    try:
                         Lista_Enemigos_3.remove(self)
                    except:
                         pass
               self.screen.blit(self.current_skin, (self.x+10, self.y+10))

          elif self.attack:
               

               if self.current_frame == 2 and not self.laser_dibujado:
                    # Centro del enemigo
                    centro_x = self.x + self.current_skin.get_width() // 2 -10
                    centro_y = self.y + self.current_skin.get_height() // 2 - 10

                    if hasattr(self, 'dir_ataque'):
                         dir_laser = self.dir_ataque
                    else:
                         dir_laser = 'der'  # por defecto

                    if dir_laser == 'izq' or dir_laser == 'der':
                         ancho = 150  # largo del láser
                         alto = 15
                    else:
                         ancho = 15
                         alto = 150

                    self.laser = LaserEnemigo(centro_x, centro_y, ancho, alto, dir_laser, ((0,255,0)))
                    self.laser.update_pos(centro_x, centro_y)
                    self.laser_dibujado = True
               if self.attack_frame_inicial:
                    self.current_frame = 0
                    self.attack_frame_inicial = False

               if current_time - self.last_update > 0.3:
                    self.last_update = current_time
                    self.current_frame += 1
                    if self.current_frame >= self.frame_count:
                         self.attack = False
                         self.laser = None
                         self.direccion_visual = None
                         self.laser_dibujado = False
                         self.cambiar_spritesheet(self.spritesheet_walk)
                         self.velocidad = self.original_velocidad  # restaurar velocidad
                         self.current_frame = 0

               self.current_skin = self.current_spritesheet.get_image(
                    self.current_frame, self.width_frame, self.height_frame, self.scale, self.colour)

               if hasattr(self, 'direccion_visual'):
                    if self.direccion_visual == 'izq':
                         self.current_skin = pg.transform.flip(self.current_skin, True, False)
                         self.current_skin.set_colorkey('black')
                    elif self.direccion_visual == 'arr':
                         self.current_skin = pg.transform.rotate(self.current_skin, 90)
                         self.current_skin.set_colorkey('black')
                    elif self.direccion_visual == 'aba':
                         self.current_skin = pg.transform.rotate(self.current_skin, -90)
                         self.current_skin.set_colorkey('black')

                    
               if self.attack and hasattr(self, 'pos_jugador'):
                    centro_jugador_x = self.pos_jugador[0] + 36
                    centro_jugador_y = self.pos_jugador[1] + 36  

                    nuevo_x = centro_jugador_x - self.current_skin.get_width() // 2
                    nuevo_y = centro_jugador_y - self.current_skin.get_height() // 2

                    self.screen.blit(self.current_skin, (nuevo_x, nuevo_y))
               else:
                         self.screen.blit(self.current_skin, (self.x, self.y))

               self.mask = pg.mask.from_surface(self.current_skin)
               if self.laser:
                    self.laser.draw(self.screen)


          else:
               if current_time - self.last_update > 0.1:
                    self.last_update = current_time
                    self.current_frame = (self.current_frame + 1) % self.frame_count

               self.current_skin = self.current_spritesheet.get_image(
                    self.current_frame, self.width_frame, self.height_frame, self.scale, self.colour)

               if self.dir == 0:  # izquierda
                    self.current_skin = pg.transform.flip(self.current_skin, True, False)
                    self.current_skin.set_colorkey('black')
               self.mask = pg.mask.from_surface(self.current_skin)
               self.screen.blit(self.current_skin, (self.x, self.y))



     
     def puede_ver_jugador(self, jugador_pos, obstáculos=None, vision_radio=300):
          
          jugador_pos = tuple(jugador_pos)

          enemigo_pos = (
               self.x + self.current_skin.get_width() // 2,
               self.y + self.current_skin.get_height() // 2
          )

          
          
          return distance(enemigo_pos, jugador_pos) <= vision_radio


     
     def perseguir_jugador(self, jugador_pos):
          self.animacion_skin()

          if self.attack:
               self.screen.blit(self.current_skin, (self.x, self.y))
               return  # no moverse durante ataque

          dx = jugador_pos[0] - self.x
          dy = jugador_pos[1] - self.y
          dist = math.hypot(dx, dy)

          if dist == 0:
               return

          dx_unit = dx / dist
          dy_unit = dy / dist

          self.x += dx_unit * self.velocidad
          self.y += dy_unit * self.velocidad

          self.screen.blit(self.current_skin, (self.x, self.y))

class LaserEnemigo:
    def __init__(self, x, y, ancho, alto, direccion, color):
        self.x = x
        self.y = y
        self.ancho = ancho
        self.alto = alto
        self.direccion = direccion  # 'izq', 'der', 'arr', 'aba'
        self.color = color
        self.color_carga = (255,50,50)
        self.image = pg.Surface((ancho, alto), pg.SRCALPHA)
        self.image.fill(color)
        self.rect = self.image.get_rect(topleft=(x, y))
        self.mask = pg.mask.from_surface(self.image)

    def draw(self, screen):
        screen.blit(self.image, (self.x, self.y))

    def update_pos(self, enemigo_x, enemigo_y):
        if self.direccion == 'izq':
            self.x = enemigo_x - self.ancho
            self.y = enemigo_y
        elif self.direccion == 'der':
            self.x = enemigo_x
            self.y = enemigo_y
        elif self.direccion == 'arr':
            self.x = enemigo_x
            self.y = enemigo_y - self.alto
        elif self.direccion == 'aba':
            self.x = enemigo_x
            self.y = enemigo_y
        self.rect.topleft = (self.x, self.y)
        self.mask = pg.mask.from_surface(self.image)

    

    

    

class BalaKugel:
    def __init__(self, x, y, vel_x, vel_y, sprite_sheet, frame_count, frame_w,frame_h, scale, colour):
        self.x = x
        self.y = y
        self.vel_x = vel_x
        self.vel_y = vel_y
        self.current_spritesheet = sprite_sheet
        self.frame_count = frame_count          #CAANTIDAD DE FRAMES DE LA SKIN DEL JUGAODR
        self.width_frame = frame_w
        self.height_frame = frame_h   #esto siempre es estatico. como las spritesheets son horizontales entonces esto que qeuda asi . 
        self.scale = scale                              #multiplicador de escala para el sprite
        self.colour = colour                  #color de fondo del sprite que se va a eliminar
        self.last_update = t.time()     #tiempo de la ultima actualizacion del frame
        self.current_frame = 0        #numero de frame que esta actualmente dibujandose.
        self.current_skin = self.current_spritesheet.get_image(0, 48, 48, self.scale, self.colour)
        self.mask= pg.mask.from_surface(self.current_skin)
        self.viva = True
        self.rect = self.current_skin.get_rect(center=(x, y))

    def update(self):
        self.animacion_skin()
        self.x += self.vel_x
        self.y += self.vel_y
        self.rect.center = (self.x, self.y)

        if self.x < 0 or self.x > 1000:
             if self.y < 0 or self.y > 1000:
                  self.viva = False

    def draw(self, screen):
        screen.blit(self.current_skin, self.rect)

    def colisiona_con(self, otro_objeto):
        # Calcular diferencia de posiciones (offset)
        offset_x = int(otro_objeto.x) - int(self.x)
        offset_y = int(otro_objeto.y) - int(self.y)
        return self.mask.overlap(otro_objeto.mask, (offset_x, offset_y)) is not None
    
    def cambiar_spritesheet(self, nuevo_spritesheet): #esto es para cambiar la spritesheet del jugador, por ejemplo cuando se ejecuta una habilidad
          self.current_spritesheet = nuevo_spritesheet #cambia el spritesheet actual al nuevo
          self.current_frame = 0  #reinicia el frame actual a 0
          self.last_update = t.time()     #reinicia el tiempo de la ultima actualizacion para que no se salte frames al cambiar de spritesheet
    
    def animacion_skin(self):
        current_time = t.time()
        if current_time - self.last_update > 0.3:
            self.last_update = current_time
            self.current_frame = (self.current_frame + 1) % self.frame_count
            self.current_skin = self.current_spritesheet.get_image(
                self.current_frame, self.width_frame, self.height_frame, self.scale, self.colour)
            self.mask = pg.mask.from_surface(self.current_skin)
             

class Boss(Enemigo3):
     def __init__(self, screen, x, y, velocidad, spritesheet_walk, spritesheet_death, sprite_attack, spritehurt, frame_count, frame_w, frame_h, scale, colour, muerte, dir, vida, spritesheet_fly, spritesheet_walk_attack, spritesheet_idle,spritesheet_melee):
          super().__init__(screen, x, y, velocidad, spritesheet_walk, spritesheet_death, sprite_attack, spritehurt, frame_count, frame_w, frame_h, scale, colour, muerte, dir, vida)
          self.spritesheet_melee = spritesheet_melee
          self.spritesheet_fly = spritesheet_fly
          self.spritesheet_walk_attack = spritesheet_walk_attack
          self.spritesheet_idle = spritesheet_idle
          self.sprite_attack = sprite_attack
          self.habilidad_actual = ""
          self.cooldown_boss = 0
          self.tiempo_habilidad_boss = 0
          self.error_de_capa_8 = 120000
          self.tiempo = pg.time.get_ticks()
          self.ejecutando_habilidad = False
          self.velocidad_buff = False
          self.pyline = False
          self.pyline_pendiente = []
          self.pyline_ultima_bomba = 0
          self.pyline_delay = 100  # milisegundos
          self.original_velocidad = velocidad
          self.john_bool_activa = False
          self.tiempo_inicio_john = 0
          self.ultima_bomba_john = 0
          self.delay_john = 300
          self.interrupcion13h = False
          self.int13henemigos = [
               [2, 0, 0],
               [3, 1, 0],
               [4, 2, 0],
               [5, 2, 1],
               [6, 3, 2],
               [0, 0, 0],
               [1, 0, 0],
               [6, 0, 0],
               [2, 0, 1],
               [1, 1, 1],
               [0, 0, 5],
               [0, 1, 0],
               [0, 2, 0],
               [0, 0, 1],
               [0, 1, 1]
               ]
          
          self.lista_balas_enemigas = []
          self.kugel_activa = False
          self.kugel_inicio_tiempo = 0
          self.kugel_duracion = 3000  # 3 segundos en milisegundos
          self.kugel_delay_entre_balas = 100  # tiempo entre disparos (ejemplo 300 ms)
          self.kugel_ultimo_disparo = 0

          self.tiempo_melee = 5000
          self.melee = False

          self.tiempo_hurt = 0
          self.time = 0
          self.healing = False

          self.resplandor_final = False
          self.calculo_renal_activo = False
          
          
          

     def escoger_habilidad(self):
         self.habilidad_actual = random.choice([
           'La_Pyline','013h','Kugelblitz','Error_de_Capa_8','El_Turing_Bus','La_venganza_de_John_Bool','El_Bombazo'
          ])
         
     


     def puede_ver_jugador(self, jugador_pos, obstáculos=None, vision_radio=1000000000000000):
          
          jugador_pos = tuple(jugador_pos)

          enemigo_pos = (
               self.x + self.current_skin.get_width() // 2,
               self.y + self.current_skin.get_height() // 2
          )

          
          
          return distance(enemigo_pos, jugador_pos) <= vision_radio
     
     def animacion_skin(self):
          current_time = t.time()
          
          

          if self.muerte:
               self.frame_count = 5
               if current_time - self.last_update > 0.3:
                    self.last_update = current_time
                    self.current_frame = (self.current_frame + 1) % self.frame_count
               self.current_skin = self.current_spritesheet.get_image(
                    self.current_frame, self.width_frame, self.height_frame, self.scale, self.colour)
               self.mask = pg.mask.from_surface(self.current_skin)
               
               self.screen.blit(self.current_skin, (self.x, self.y))

          elif self.attack:
               

               if self.current_frame == 2 and not self.laser_dibujado:
                    # Centro del enemigo
                    centro_x = self.x + self.current_skin.get_width() // 2 
                    centro_y = self.y + self.current_skin.get_height() // 2 

                    if hasattr(self, 'dir_ataque'):
                         dir_laser = self.dir_ataque
                    else:
                         dir_laser = 'der'  # por defecto

                    if dir_laser == 'izq' or dir_laser == 'der':
                         ancho = 150  # largo del láser
                         alto = 15
                    else:
                         ancho = 15
                         alto = 150

                    self.laser = LaserEnemigo(centro_x, centro_y, ancho, alto, dir_laser)
                    self.laser.update_pos(centro_x, centro_y)
                    self.laser_dibujado = True
               if self.attack_frame_inicial:
                    self.current_frame = 0
                    self.attack_frame_inicial = False

               if current_time - self.last_update > 0.3:
                    self.last_update = current_time
                    self.current_frame += 1
                    if self.current_frame >= self.frame_count:
                         self.attack = False
                         self.laser = None
                         self.direccion_visual = None
                         self.laser_dibujado = False
                         self.cambiar_spritesheet(self.spritesheet_walk)
                         self.velocidad = self.original_velocidad  # restaurar velocidad
                         self.current_frame = 0

               # 1. Obtener frame original SIN modificar
               frame_sin_transformar = self.current_spritesheet.get_image(
                    self.current_frame, self.width_frame, self.height_frame, self.scale, self.colour)

               # 2. Aplicar transformación y asignar a current_skin
               if hasattr(self, 'direccion_visual'):
                    if self.direccion_visual == 'izq':
                         self.current_skin = pg.transform.flip(frame_sin_transformar, True, False)
                    elif self.direccion_visual == 'arr':
                         self.current_skin = pg.transform.rotate(frame_sin_transformar, 90)
                    elif self.direccion_visual == 'aba':
                         self.current_skin = pg.transform.rotate(frame_sin_transformar, -90)
                    else:
                         self.current_skin = frame_sin_transformar
               else:
                    self.current_skin = frame_sin_transformar

               self.current_skin.set_colorkey('black')

                    
               if self.attack and hasattr(self, 'pos_jugador'):
                    centro_jugador_x = self.pos_jugador[0] + 36
                    centro_jugador_y = self.pos_jugador[1] + 36  

                    nuevo_x = centro_jugador_x - self.current_skin.get_width() // 2
                    nuevo_y = centro_jugador_y - self.current_skin.get_height() // 2

                    self.screen.blit(self.current_skin, (nuevo_x, nuevo_y))
               else:
                         self.screen.blit(self.current_skin, (self.x, self.y))

               self.mask = pg.mask.from_surface(self.current_skin)
               if self.laser:
                    self.laser.draw(self.screen)


          else:
               if current_time - self.last_update > 0.1:
                    self.last_update = current_time
                    self.current_frame = (self.current_frame + 1) % self.frame_count

               self.current_skin = self.current_spritesheet.get_image(
                    self.current_frame, self.width_frame, self.height_frame, self.scale, self.colour)

               if self.dir == 0:  # izquierda
                    self.current_skin = pg.transform.flip(self.current_skin, True, False)
                    self.current_skin.set_colorkey('black')
               self.mask = pg.mask.from_surface(self.current_skin)
               self.screen.blit(self.current_skin, (self.x, self.y))
          
          

     def perseguir_jugador(self, pos_jugador): 
          if self.current_spritesheet == self.spritehurt:
               
               self.tiempo_hurt = pg.time.get_ticks()
               
               if self.tiempo_hurt - self.time >= 2000:
                     self.cambiar_spritesheet(self.spritesheet_walk)
          tiempo = pg.time.get_ticks()
          if not self.ejecutando_habilidad:
               if tiempo - self.cooldown_boss >= 5000:
                    self.escoger_habilidad()
                    print(self.habilidad_actual)
                    self.ejecutar_habilidad()

          if self.habilidad_actual == 'El_Turing_Bus' and self.velocidad_buff:
               if tiempo - self.tiempo_habilidad_boss > 3000:
                    self.velocidad = self.velocidad/1.5
                    self.velocidad_buff = False
                    self.habilidad_actual = ""
                    self.cambiar_spritesheet(self.spritesheet_walk)
                    self.cooldown_boss = pg.time.get_ticks()

          if self.habilidad_actual == 'La_Pyline' and self.pyline:   
               if self.pyline_pendiente:
                    tiempo_actual = pg.time.get_ticks()
                    if tiempo_actual - self.pyline_ultima_bomba >= self.pyline_delay:
                         fila, col = self.pyline_pendiente.pop(0)
                         matriz[fila][col] = 6
                         self.pyline_ultima_bomba = tiempo_actual
               else:
                         self.pyline = False  
                         self.habilidad_actual = ""
                         self.velocidad = self.original_velocidad
                         self.cambiar_spritesheet(self.spritesheet_walk)
                         self.cooldown_boss = pg.time.get_ticks()
          
          if self.john_bool_activa:
              
               tiempo_actual = pg.time.get_ticks()

               # Cada 0.5s pone un 6 en la celda donde está el jugador
               if tiempo_actual - self.ultima_bomba_john >= self.delay_john:
                    fila = int((pos_jugador[1]+16) // 48)
                    col = int((pos_jugador[0]+16) // 48)
                    if 0 <= fila < len(matriz) and 0 <= col < len(matriz[0]):
                         matriz[fila][col] = 6
                    self.ultima_bomba_john = tiempo_actual

               # Después de 3 segundos termina la habilidad
               if tiempo_actual - self.tiempo_inicio_john >= 10000:
                    self.john_bool_activa = False
                    self.habilidad_actual = ""
                    self.cambiar_spritesheet(self.spritesheet_walk)
                    self.cooldown_boss = pg.time.get_ticks()
                    self.velocidad = self.original_velocidad

          if self.interrupcion13h:
                    self.habilidad_actual = ""
                    self.cooldown_boss = pg.time.get_ticks()
                    self.velocidad = self.original_velocidad
                    self.cambiar_spritesheet(self.spritesheet_walk)
                    self.interrupcion13h = False
                    limpiar_enemigos()

          if self.kugel_activa:
                tiempo_actual = pg.time.get_ticks()
                tiempo_pasado = tiempo_actual - self.kugel_inicio_tiempo
               
                if tiempo_pasado > self.kugel_duracion:
                    # Fin de la habilidad
                    self.kugel_activa = False
                    self.habilidad_actual = ""
                    self.cooldown_boss = tiempo_actual
                    self.velocidad = self.original_velocidad
                    self.cambiar_spritesheet(self.spritesheet_walk)

                else:
            # Disparar balas cada 'kugel_delay_entre_balas' milisegundos
                    if tiempo_actual - self.kugel_ultimo_disparo >= self.kugel_delay_entre_balas:
                         self.kugel_ultimo_disparo = tiempo_actual
                         self.disparar()

          if self.melee:
               tiempo_actual = pg.time.get_ticks()
               #aca colisiones del bombazo
               
               if tiempo_actual - self.tiempo_habilidad_boss >= 3000 :
                    # Fin de la habilidad
                    self.habilidad_actual = ""
                    self.cooldown_boss = tiempo_actual
                    self.velocidad = self.original_velocidad
                    self.cambiar_spritesheet(self.spritesheet_walk)
                    self.melee = False
          
          if self.healing:
               tiempo_actual = pg.time.get_ticks()
               self.vida += 70
               boss_healing.play()
               self.habilidad_actual = ""
               self.cooldown_boss = tiempo_actual
               self.velocidad = self.original_velocidad
               self.cambiar_spritesheet(self.spritesheet_walk)
               self.healing = False

          if self.calculo_renal_activo:
               tiempo_actual = pg.time.get_ticks()
               if self.pyline_pendiente:
                    if tiempo_actual - self.pyline_ultima_bomba >= self.pyline_delay:
                         fila, col = self.pyline_pendiente.pop(0)
                         matriz[fila][col] = 6
                         self.pyline_ultima_bomba = tiempo_actual
               else:
                    self.calculo_renal_activo = False
                    self.resplandor_final = False
                    try:
                         Lista_Boss.remove(self)
                    except:
                         pass


               
          
          self.actualizar_kugels()
          for bala in self.lista_balas_enemigas:
            bala.draw(self.screen)

          dx = pos_jugador[0] - self.x - 192
          dy = pos_jugador[1] - self.y - 192
          distancia = math.hypot(dx, dy)

          if distancia == 0:
               return

          dx_norm = dx / distancia
          dy_norm = dy / distancia

          self.x += dx_norm * self.velocidad
          self.y += dy_norm * self.velocidad

          self.animacion_skin()  

     def ejecutar_habilidad(self):
          self.cooldown_boss = pg.time.get_ticks()
          self.tiempo_habilidad_boss = pg.time.get_ticks()

          if self.habilidad_actual == 'El_Turing_Bus':
               self.velocidad *= 1.5
               self.cambiar_spritesheet(self.spritesheet_walk_attack)
               self.velocidad_buff = True

          if self.habilidad_actual == 'La_Pyline':
               self.velocidad = 0
               self.cambiar_spritesheet(self.spritesheet_fly)
               self.pyline = True
               self.ejecutar_pyline()

          if self.habilidad_actual == 'La_venganza_de_John_Bool':
                self.john_bool_activa = True
                self.velocidad = 0
                self.cambiar_spritesheet(self.spritesheet_fly)

                self.tiempo_inicio_john = pg.time.get_ticks()
                self.ultima_bomba_john = pg.time.get_ticks()

          if self.habilidad_actual == '013h':

               self.interrupcion13h = True
               self.velocidad = 0
               self.cambiar_spritesheet(self.spritesheet_idle)
               config = random.choice(self.int13henemigos)
               print(config)
               cant_1, cant_2, cant_3 = config
               self.spawn_enemigos_013h(cant_1, cant_2, cant_3)
          
          if self.habilidad_actual == 'Kugelblitz':
            
            self.cambiar_spritesheet(self.spritesheet_walk_attack)
            self.kugel_activa = True
            self.kugel_inicio_tiempo = pg.time.get_ticks()
            self.kugel_ultimo_disparo = 0

          if self.habilidad_actual == 'El_Bombazo':
               self.velocidad = 1.5
               self.cambiar_spritesheet(self.spritesheet_melee)
               self.melee = True
          
          if self.habilidad_actual == 'Error_de_Capa_8':
               self.healing = True
               
            
            
          
     def disparar(self):
            global pos_jugador, spritesheet_BB
            
            self.cambiar_spritesheet(self.sprite_attack)
            
            origen_x = self.x + self.current_skin.get_width() // 2
            origen_y = self.y + self.current_skin.get_height() // 2

            objetivo_x = pos_jugador[0] 
            objetivo_y = pos_jugador[1] - 2

            dx = objetivo_x - origen_x
            dy = objetivo_y - origen_y
            
            distancia = math.hypot(dx, dy)
            if distancia == 0:
                distancia = 1 

            vel_x = dx / distancia * 14 
            vel_y = dy / distancia * 14

            bala = BalaKugel(origen_x, origen_y, vel_x, vel_y, spritesheet_BB, 5, 48, 48, 2, 'black')
            self.lista_balas_enemigas.append(bala)
          
     def spawn_enemigos_013h(self, cant_1, cant_2, cant_3):
          global matriz, Lista_Enemigos_1, Lista_Enemigos_2, Lista_Enemigos_3
          filas = len(matriz)
          columnas = len(matriz[0])

          # Paso 1: Crear una lista de posiciones válidas
          celdas_validas = [
               (f, c)
               for f in range(filas)
               for c in range(columnas)
               if matriz[f][c] not in ['#', 4, 6, 1, 2, 3,'*']  # celda libre
          ]

          # Paso 2: Aleatorizar la lista de celdas
          random.shuffle(celdas_validas)

          # Paso 3: Definir cuántos enemigos en total colocar
          total = cant_1 + cant_2 + cant_3
          contador = {1: cant_1, 2: cant_2, 3: cant_3}

          # Paso 4: Colocar en orden hasta que se acabe la lista o los enemigos
          for f, c in celdas_validas:
               if total <= 0:
                    break

               for tipo in [1, 2, 3]:
                    if contador[tipo] > 0:
                         matriz[f][c] = tipo
                         if tipo == 1:
                              Enemigo_perro = Enemigos(self.screen, (c*48), (f*48), 1.1, spritesheet_perro_cañon, spritesheet_perro_muerte, 3, 48, 48, 1, 'black', False, random.randint(0,3))
                              Lista_Enemigos_1 += [Enemigo_perro]

                         if tipo == 2:
                              Enemigo_Moreno = Enemigo2(self.screen, (c*48), (f*48), 1.1, spritesheet_Moreno, spritesheet_moreno_muerte,spritesheet_moreno_hurt, 5, 48, 48, 1, 'black', False, random.randint(0,3),50) 
                              Lista_Enemigos_2 += [Enemigo_Moreno]

                         if tipo == 3:
                              Enemigo_Volador = Enemigo3(self.screen, (c*48), (f*48), 1.3, spritesheet_volador, spritesheet_volador_muerte,spritesheet_v_a, spritesheet_v_a,3, 72, 72, 0.8, 'black', False, random.randint(0,3),70) 
                              Lista_Enemigos_3 += [Enemigo_Volador]

                         contador[tipo] -= 1
                         total -= 1
                         break
     
     def actualizar_kugels(self):
          for bala in self.lista_balas_enemigas[:]:
               bala.update()
               if not bala.viva:
                    self.lista_balas_enemigas.remove(bala)
          

     def ejecutar_pyline(self):
          global Fuerza_exp_boss
          Fuerza_exp_boss = 20

          self.pyline_pendiente.clear()
          self.pyline_activa = True
          self.pyline_ultima_bomba = pg.time.get_ticks()

          filas = len(matriz)
          columnas = len(matriz[0])

          # 1. Borde superior (izquierda a derecha)
          for col in range(0, columnas):
               self.pyline_pendiente.append((0, col))

          # 2. Borde derecho (de arriba a abajo, sin esquina ya usada)
          for fila in range(1, filas):
               self.pyline_pendiente.append((fila, columnas - 1))

          # 3. Borde inferior (derecha a izquierda, sin esquina ya usada)
          for col in reversed(range(0, columnas - 1)):
               self.pyline_pendiente.append((filas - 1, col))

          # 4. Borde izquierdo (de abajo a arriba, sin esquina ya usada)
          for fila in reversed(range(1, filas - 1)):
               self.pyline_pendiente.append((fila, 0))

     def calculo_renal(self):
          global Fuerza_exp_boss
          self.tiempo_habilidad_boss = pg.time.get_ticks()
          self.habilidad_actual = "La_Pyline"
          self.calculo_renal_activo = True
          self.resplandor_final = True
          self.pyline_delay = 0 
          Fuerza_exp_boss = 20

          self.pyline_pendiente.clear()
          self.pyline_activa = True
          self.pyline_ultima_bomba = pg.time.get_ticks()

          filas = len(matriz)
          columnas = len(matriz[0])

          top = 0
          bottom = filas - 1
          left = 0
          right = columnas - 1

          while top <= bottom and left <= right:
               # Recorrer parte superior izquierda a derecha
               for col in range(left, right + 1):
                    self.pyline_pendiente.append((top, col))
               top += 1

               # Recorrer lado derecho arriba a abajo
               for fila in range(top, bottom + 1):
                    self.pyline_pendiente.append((fila, right))
               right -= 1

               # Recorrer parte inferior derecha a izquierda
               if top <= bottom:
                    for col in reversed(range(left, right + 1)):
                         self.pyline_pendiente.append((bottom, col))
                    bottom -= 1

               # Recorrer lado izquierdo abajo a arriba
               if left <= right:
                    for fila in reversed(range(top, bottom + 1)):
                         self.pyline_pendiente.append((fila, left))
                    left += 1
          calculo_final()


def calculo_final():
     global matriz, obstacles, obstacles_R
     for fil in range(len(matriz)):
             for col in range(len(matriz[fil])):
                       if matriz[fil][col] in (0,1,8,9,'u','d','l','r','w','a','s','f','c','U','D','L','R','W','A','S','D','F','C',2,3,4,'#','*'):
                            matriz[fil][col] = 0  
     obstacles_R = []
     obstacles = []

def limpiar_enemigos():
     global matriz
     for fil in range(len(matriz)):
             for col in range(len(matriz[fil])):
                       if matriz[fil][col] in (1,2,3):
                            matriz[fil][col] = 0    
#Class Bomba_sprite
class Bomba:
    
     def __init__(self, screen, x, y, spritesheet_bomba, frame_count, frame_w,frame_h, scale, colour, explosion):
          self.screen = screen
          self.x = x
          self.y = y
          self.current_spritesheet = spritesheet_bomba
          self.frame_count = frame_count          #CAANTIDAD DE FRAMES DE LA SKIN DEL JUGAODR
          self.width_frame = frame_w
          self.height_frame = frame_h   #esto siempre es estatico. como las spritesheets son horizontales entonces esto que qeuda asi . 
          self.scale = scale                              #multiplicador de escala para el sprite
          self.colour = colour                  #color de fondo del sprite que se va a eliminar
          self.last_update = t.time()     #tiempo de la ultima actualizacion del frame
          self.current_frame = 0        #numero de frame que esta actualmente dibujandose.
          self.current_skin = self.current_spritesheet.get_image(0, 48, 48, self.scale, self.colour)
          self.mask= pg.mask.from_surface(self.current_skin)
          self.bomba_animacion = explosion

     def animate(self):
       if self.bomba_animacion:
          self.animacion_skin()
          if self.current_frame == 4:
               self.bomba_animacion = False
               E_1.bomba_animacion = True
          self.screen.blit(self.current_skin, (self.x, self.y))


     def auto_animate(self):
                    self.animate()

     def cambiar_spritesheet(self, nuevo_spritesheet): #esto es para cambiar la spritesheet del jugador, por ejemplo cuando se ejecuta una habilidad
        self.current_spritesheet = nuevo_spritesheet #cambia el spritesheet actual al nuevo
        self.current_frame = 0  #reinicia el frame actual a 0
        self.last_update = t.time()     #reinicia el tiempo de la ultima actualizacion para que no se salte frames al cambiar de spritesheet
    
     def animacion_skin(self) : 
        current_time = t.time()
        if current_time - self.last_update > 0.4 : # Cambio de frame cada 0.2 segundos
            self.last_update = current_time
            self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
        self.current_skin = self.current_spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)
        self.mask = pg.mask.from_surface(self.current_skin)
    
     def colisiona_con(self, otro_objeto):
        # Calcular diferencia de posiciones (offset)
        offset_x = int(otro_objeto.x) - int(self.x)
        offset_y = int(otro_objeto.y) - int(self.y)
        return self.mask.overlap(otro_objeto.mask, (offset_x, offset_y)) is not None

class Bomba_Matriz(Bomba):
     def __init__(self, screen, x, y, spritesheet_bomba, frame_count, frame_w, frame_h, scale, colour, explosion):
          super().__init__(screen, x, y, spritesheet_bomba, frame_count, frame_w, frame_h, scale, colour, explosion)

     def animate_matriz(self):
       if self.bomba_animacion:
          self.animacion_skin()
          if self.current_frame == 4:
               matriz[int(self.y//48)][int(self.x//48)] = 9
               sfx_bomba.play()
               lista_B.remove(self)
          self.screen.blit(self.current_skin, (self.x, self.y))

     def auto_animate(self):
                    
                    self.animate_matriz()

class Explosion:
     def __init__(self, screen, x, y, spritesheet_exp, frame_count, frame_w,frame_h, scale, colour, explosion):
          self.screen = screen
          self.x = x
          self.y = y
          self.current_spritesheet = spritesheet_exp
          self.frame_count = frame_count          #CAANTIDAD DE FRAMES DE LA SKIN DEL spritesheet
          self.width_frame = frame_w
          self.height_frame = frame_h   #esto siempre es estatico. como las spritesheets son horizontales entonces esto que qeuda asi . 
          self.scale = scale                              #multiplicador de escala para el sprite
          self.colour = colour                  #color de fondo del sprite que se va a eliminar
          self.last_update = t.time()     #tiempo de la ultima actualizacion del frame
          self.current_frame = 0        #numero de frame que esta actualmente dibujandose.
          self.current_skin = self.current_spritesheet.get_image(0, 48, 48, self.scale, self.colour)
          self.mask= pg.mask.from_surface(self.current_skin)
          self.bomba_animacion = explosion

     def animate(self):
       if self.bomba_animacion:
          self.animacion_skin()
          if self.current_frame == 3:
               E_1.bomba_animacion = False
          self.screen.blit(self.current_skin, (self.x, self.y))


     def auto_animate(self):
                    self.animate()

     def cambiar_spritesheet(self, nuevo_spritesheet): #esto es para cambiar la spritesheet del jugador, por ejemplo cuando se ejecuta una habilidad
        self.current_spritesheet = nuevo_spritesheet #cambia el spritesheet actual al nuevo
        self.current_frame = 0  #reinicia el frame actual a 0
        self.last_update = t.time()     #reinicia el tiempo de la ultima actualizacion para que no se salte frames al cambiar de spritesheet
    
     def animacion_skin(self) : 
        current_time = t.time()
        if current_time - self.last_update > 0.1 : # Cambio de frame cada 0.2 segundos
            self.last_update = current_time
            self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
        self.current_skin = self.current_spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)
        self.mask = pg.mask.from_surface(self.current_skin)
    
     def colisiona_con(self, otro_objeto):
        # Calcular diferencia de posiciones (offset)
        offset_x = int(otro_objeto.x) - int(self.x)
        offset_y = int(otro_objeto.y) - int(self.y)
        return self.mask.overlap(otro_objeto.mask, (offset_x, offset_y)) is not None
   
class Explosion_Matriz(Explosion):
     def __init__(self, screen, x, y, spritesheet_exp, frame_count, frame_w, frame_h, scale, colour, explosion):
          super().__init__(screen, x, y, spritesheet_exp, frame_count, frame_w, frame_h, scale, colour, explosion)
          self.matriz = matriz
          # Flags por dirección: False hasta que marque el primer '*'
          self.star_up = False
          self.star_down = False
          self.star_right = False
          self.star_left = False

     def animate_matriz(self):
       if self.bomba_animacion:
          self.animacion_skin()
          if self.current_frame == 3:
               lista_E.remove(self)
          self.screen.blit(self.current_skin, (self.x, self.y))
     
     def auto_animate(self):
                    self.animate_matriz()
     
class Explosion_Matriz_Lados(Explosion_Matriz):
     def __init__(self, screen, x, y, spritesheet_exp, frame_count, frame_w, frame_h, scale, colour, explosion, direccion):
          super().__init__(screen, x, y, spritesheet_exp, frame_count, frame_w, frame_h, scale, colour, explosion)
          self.dir = direccion

     def animate_matriz(self):
       if self.bomba_animacion:
          self.animacion_skin()
          if self.dir == 'u':
               self.current_skin = pg.transform.rotate(self.current_skin, 90)
               self.current_skin.set_colorkey('black')
          if self.dir == 'd':
               self.current_skin = pg.transform.rotate(self.current_skin, 270)
               self.current_skin.set_colorkey('black')
          if self.dir == 'a':
               self.current_skin = pg.transform.flip(self.current_skin, False, False)
               self.current_skin.set_colorkey('black')

          if self.dir == 's':
               self.current_skin = pg.transform.rotate(self.current_skin, 90)
               self.current_skin.set_colorkey('black')
          if self.dir == 'w':
               self.current_skin = pg.transform.rotate(self.current_skin, 270)
               self.current_skin.set_colorkey('black')

          if self.dir == 'f':
               self.current_skin = pg.transform.flip(self.current_skin, True, False)
               self.current_skin.set_colorkey('black')

          if self.current_frame == 3:
              lista_EL.remove(self)
          self.screen.blit(self.current_skin, (self.x, self.y))

     def animacion_skin(self) : 
        current_time = t.time()
        if current_time - self.last_update > 0.1 : # Cambio de frame cada 0.2 segundos
            self.last_update = current_time
            self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
        self.current_skin = self.current_spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)
        self.mask = pg.mask.from_surface(self.current_skin)

     def auto_animate(self):
                    self.animate_matriz()

class Item  : 
     def __init__ (self, screen, x, y, spritesheet, tipo):
          self.screen = screen
          self.x = x
          self.y = y
          self.tipo = tipo
          self.spritesheet = spritesheet
          self.mask= pg.mask.from_surface(self.spritesheet)

class llave_candado : 
     def __init__(self, x,y,llave, candado, img):
          self.x = x
          self.y = y
          self.llave = llave
          self.candado = candado
          self.img= img
          self.mask = pg.mask.from_surface(self.img)

class Bomba_boss:
    
     def __init__(self, screen, x, y, spritesheet_bomba, frame_count, frame_w,frame_h, scale, colour, explosion):
          self.screen = screen
          self.x = x
          self.y = y
          self.current_spritesheet = spritesheet_bomba
          self.frame_count = frame_count          #CAANTIDAD DE FRAMES DE LA SKIN DEL JUGAODR
          self.width_frame = frame_w
          self.height_frame = frame_h   #esto siempre es estatico. como las spritesheets son horizontales entonces esto que qeuda asi . 
          self.scale = scale                              #multiplicador de escala para el sprite
          self.colour = colour                  #color de fondo del sprite que se va a eliminar
          self.last_update = t.time()     #tiempo de la ultima actualizacion del frame
          self.current_frame = 0        #numero de frame que esta actualmente dibujandose.
          self.current_skin = self.current_spritesheet.get_image(0, 48, 48, self.scale, self.colour)
          self.mask= pg.mask.from_surface(self.current_skin)
          self.bomba_animacion = explosion

     def animate(self):
       if self.bomba_animacion:
          self.animacion_skin()
          if self.current_frame == 4:
               self.bomba_animacion = False
               E_1.bomba_animacion = True
          self.screen.blit(self.current_skin, (self.x, self.y))


     def auto_animate(self):
                    self.animate()

     def cambiar_spritesheet(self, nuevo_spritesheet): #esto es para cambiar la spritesheet del jugador, por ejemplo cuando se ejecuta una habilidad
        self.current_spritesheet = nuevo_spritesheet #cambia el spritesheet actual al nuevo
        self.current_frame = 0  #reinicia el frame actual a 0
        self.last_update = t.time()     #reinicia el tiempo de la ultima actualizacion para que no se salte frames al cambiar de spritesheet
    
     def animacion_skin(self) : 
        current_time = t.time()
        if current_time - self.last_update > 0.4 : # Cambio de frame cada 0.2 segundos
            self.last_update = current_time
            self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
        self.current_skin = self.current_spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)
        self.mask = pg.mask.from_surface(self.current_skin)
    
     def colisiona_con(self, otro_objeto):
        # Calcular diferencia de posiciones (offset)
        offset_x = int(otro_objeto.x) - int(self.x)
        offset_y = int(otro_objeto.y) - int(self.y)
        return self.mask.overlap(otro_objeto.mask, (offset_x, offset_y)) is not None

class Bomba_Matriz_boss(Bomba_boss):
     def __init__(self, screen, x, y, spritesheet_bomba, frame_count, frame_w, frame_h, scale, colour, explosion):
          super().__init__(screen, x, y, spritesheet_bomba, frame_count, frame_w, frame_h, scale, colour, explosion)

     def animate_matriz(self):
       if self.bomba_animacion:
          self.animacion_skin()
          if self.current_frame == 4:
               matriz[int(self.y//48)][int(self.x//48)] = 7
               sfx_bomba.play()
               lista_B_Boss.remove(self)
          self.screen.blit(self.current_skin, (self.x, self.y))

     def auto_animate(self):
                    self.animate_matriz()

class Explosion_boss:
     def __init__(self, screen, x, y, spritesheet_exp, frame_count, frame_w,frame_h, scale, colour, explosion):
          self.screen = screen
          self.x = x
          self.y = y
          self.current_spritesheet = spritesheet_exp
          self.frame_count = frame_count          #CAANTIDAD DE FRAMES DE LA SKIN DEL spritesheet
          self.width_frame = frame_w
          self.height_frame = frame_h   #esto siempre es estatico. como las spritesheets son horizontales entonces esto que qeuda asi . 
          self.scale = scale                              #multiplicador de escala para el sprite
          self.colour = colour                  #color de fondo del sprite que se va a eliminar
          self.last_update = t.time()     #tiempo de la ultima actualizacion del frame
          self.current_frame = 0        #numero de frame que esta actualmente dibujandose.
          self.current_skin = self.current_spritesheet.get_image(0, 48, 48, self.scale, self.colour)
          self.mask= pg.mask.from_surface(self.current_skin)
          self.bomba_animacion = explosion

     def animate(self):
       if self.bomba_animacion:
          self.animacion_skin()
          if self.current_frame == 3:
               E_1.bomba_animacion = False
          self.screen.blit(self.current_skin, (self.x, self.y))


     def auto_animate(self):
                    self.animate()

     def cambiar_spritesheet(self, nuevo_spritesheet): #esto es para cambiar la spritesheet del jugador, por ejemplo cuando se ejecuta una habilidad
        self.current_spritesheet = nuevo_spritesheet #cambia el spritesheet actual al nuevo
        self.current_frame = 0  #reinicia el frame actual a 0
        self.last_update = t.time()     #reinicia el tiempo de la ultima actualizacion para que no se salte frames al cambiar de spritesheet
    
     def animacion_skin(self) : 
        current_time = t.time()
        if current_time - self.last_update > 0.1 : # Cambio de frame cada 0.2 segundos
            self.last_update = current_time
            self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
        self.current_skin = self.current_spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)
        self.mask = pg.mask.from_surface(self.current_skin)
    
     def colisiona_con(self, otro_objeto):
        # Calcular diferencia de posiciones (offset)
        offset_x = int(otro_objeto.x) - int(self.x)
        offset_y = int(otro_objeto.y) - int(self.y)
        return self.mask.overlap(otro_objeto.mask, (offset_x, offset_y)) is not None
     
class Explosion_Matriz_boss(Explosion_boss):
     def __init__(self, screen, x, y, spritesheet_exp, frame_count, frame_w, frame_h, scale, colour, explosion):
          super().__init__(screen, x, y, spritesheet_exp, frame_count, frame_w, frame_h, scale, colour, explosion)
          self.matriz = matriz
          # Flags por dirección: False hasta que marque el primer '*'
          self.star_up = False
          self.star_down = False
          self.star_right = False
          self.star_left = False

     def animate_matriz(self):
       if self.bomba_animacion:
          self.animacion_skin()
          if self.current_frame == 3:
               lista_E_Boss.remove(self)
          self.screen.blit(self.current_skin, (self.x, self.y))
     
     def auto_animate(self):
                    self.animate_matriz()
     
class Explosion_Matriz_Lados_Boss(Explosion_Matriz):
     def __init__(self, screen, x, y, spritesheet_exp, frame_count, frame_w, frame_h, scale, colour, explosion, direccion):
          super().__init__(screen, x, y, spritesheet_exp, frame_count, frame_w, frame_h, scale, colour, explosion)
          self.dir = direccion

     def animate_matriz(self):
       if self.bomba_animacion:
          self.animacion_skin()
          if self.dir == 'U':
               self.current_skin = pg.transform.rotate(self.current_skin, 90)
               self.current_skin.set_colorkey('black')
          if self.dir == 'D':
               self.current_skin = pg.transform.rotate(self.current_skin, 270)
               self.current_skin.set_colorkey('black')
          if self.dir == 'A':
               self.current_skin = pg.transform.flip(self.current_skin, False, False)
               self.current_skin.set_colorkey('black')

          if self.dir == 'S':
               self.current_skin = pg.transform.rotate(self.current_skin, 90)
               self.current_skin.set_colorkey('black')
          if self.dir == 'W':
               self.current_skin = pg.transform.rotate(self.current_skin, 270)
               self.current_skin.set_colorkey('black')

          if self.dir == 'F':
               self.current_skin = pg.transform.flip(self.current_skin, True, False)
               self.current_skin.set_colorkey('black')

          if self.current_frame == 3:
              lista_EL_Boss.remove(self)
          self.screen.blit(self.current_skin, (self.x, self.y))

     def animacion_skin(self) : 
        current_time = t.time()
        if current_time - self.last_update > 0.1 : # Cambio de frame cada 0.2 segundos
            self.last_update = current_time
            self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
        self.current_skin = self.current_spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)
        self.mask = pg.mask.from_surface(self.current_skin)

     def auto_animate(self):
                    self.animate_matriz()
#-----------------------pygame------------------------------
#SONIDOS DEL JUEGO
mixer.init()
boss_healing = mixer.Sound("sounds\sfx\healing.mp3")
#commons de pygame (literalmente el inicio de pygame)
pg.init()
screen= pg.display.set_mode((816, 624)) #tamano de pantalla
pg.display.set_caption("El hombre que tiraba bombas") #Nombre de la ventana
tiempo_juego= Reloj(300)
reloj = pg.time.Clock() #reloj comun para controlar FPS

RUTA_PLAYS= "games\player_data\plays.json"


#*!super importante, SI NO NO CARGA NADA (FUE UNA EPIFANIA QUE TUVE)
perro= pg.image.load("assets\perro.png").convert_alpha()
esteman= pg.image.load("assets\STEMAN.png").convert_alpha()
esteman=pg.transform.scale(esteman, (112, 199)) #redimensiona la imagen de Steadman a 112x199
benja= pg.image.load("assets\BENJA.png").convert_alpha()
benja=pg.transform.scale(benja, (138, 184)) #redimensiona la imagen de Benja a 128x128

#*!-----------------------GLOBALES------------------------------
pos_jugador = None
estado = "menu" #se inicializa el estado del juego como "start", que representa el menu de inicio (ahorita esta en seleccion de pers por unas pruebas q taba haciendo)
estado_anterior=""
start_time_pantalla=0
#Globales Steadman
obstacles = [] #lista de colisiones con obstaculos
obstacles_R = [] #lista de los rompibles
nivel = 0  #nivel inicial-1
#cuando
matriz = [] #la matriz extraida del nivel inicial
items_en_nivel=[]  #lista de objetos items . se renderizan en el inicio del juego pero aparecen ocultos hasta la puta 
Lista_Enemigos_1 = [] #la lista de los enemigos, esta solo posee los enemigos del nivel 1 o los mas sencillos
Fuerza_exp = 1 #Esto dice la fuerza de la explosion, se va a expandir en casillas en forma de cruz, si es 1 es una casilla extra
Fuerza_exp_boss = 20
lista_B = [] #lista de bombas, solo para multiples animaciones a la vez
lista_E = [] #lista de explosiones, solo para multiples 
lista_EL = [] #lista para las explosiones extra o de lado o de borde
lista_B_Boss = []
lista_E_Boss = []
lista_EL_Boss = []
bomba_in_bounds = False
Lista_Enemigos_2 = [] #para los enemigos morenos
Lista_Enemigos_3 = []
Lista_Boss = [] #solo boss
traps = []
hielo = []
lista_pw_uso = [] #lista de powerups usados
#___________________Enemigos y Aparicion de obstaculos________________________
CELL_SIZE = 48 #tamaño por celda para la aparicion de todo XDXDXDXDX
W_GRID = 17 #debido a que no es un cuadrado se debe definir un tamaño por ancho y alto
H_GRID = 13

primera_vez = True #debido a que ciertas cosas SOLO se deben generar una vez por nivel, como ver sus posiciones, se hace este booleano
llave = None  # Variable global para la llave
candado= None
#-----------------------GLOBALES Y CARACTERISTICAS DEL JUEGO------------------------------
puntaje_nivel=0
puntaje_final=0
global_fade=False
global_cuadrado=False
bara_texto =""
nombre_jugador=""
jugadas =[]
powerups=None
#-------------area de juego-----------
game_surface = pg.Surface((816,528)) #*! ya cambie el tamano del frame enves de 624 a 524, estaba pintando el frame 100 pix hacia abajo y hacia que pete todo

#------------------------TEXTURAS------------------------------
heart_texture = pg.image.load("assets/textures/heart.png").convert_alpha() #carga la textura del corazon
#--------------------FONDOS-----------------------------------
pos_par_men= [0] * 7
fondo_p_men=[ pg.image.load("assets\Backgrounds\opciones\layer5.png").convert_alpha() ,pg.image.load("assets\Backgrounds\opciones\layer4.png").convert_alpha() ,pg.image.load("assets\Backgrounds\opciones\layer3.png").convert_alpha() ,pg.image.load("assets\Backgrounds\opciones\layer2.png").convert_alpha() ,pg.image.load("assets\Backgrounds\opciones\layer1.png").convert_alpha() ,pg.image.load("assets\Backgrounds\opciones\layer0.png").convert_alpha() ]
fondos_p_op = [pg.image.load("assets/backgrounds/menu/layer3.png"),pg.image.load("assets/backgrounds/menu/layer2.png"),pg.image.load("assets/backgrounds/menu/layer1.png"),pg.image.load("assets/backgrounds/menu/layer0.png")]
fondo_compra= pg.image.load("assets\Backgrounds\compra.png") #fondo de la pantalla de compra de powerups
#------------------------SPRITES DE JUGADORES------------------------------
sps_habilidades= pg.image.load ("assets\Textures\habilities.png").convert_alpha()
sps_items = pg.image.load("assets\Textures\items.png").convert_alpha()
sps_powerups=pg.image.load("assets\Textures\powerups.png").convert_alpha()
sps_nuke= pg.image.load("assets\Textures\\Nuke.png").convert_alpha() #sprite de la bomba nuclear

#--- Intangible ----
preview_intangible = pg.image.load("assets\sprites\players\Intangible\preview.png").convert_alpha() 
imp_sps_intangible_idle= pg.image.load("assets\sprites\players\Intangible\idle.png").convert_alpha() #placeholder para el sprite intangible
imp_sps_intalgible_hab= pg.image.load("assets\sprites\players\Intangible\especial.png").convert_alpha() #placeholder para el sprite intangible de habilidad
imp_sps_intangible_walk= pg.image.load("assets\sprites\players\Intangible\walk.png").convert_alpha() #placeholder para el sprite intangible de correr
imp_sps_intangible_death=pg.image.load("assets\sprites\players\Intangible\death.png").convert_alpha() #placeholder para el sprite intangible de correr
#----tactico----
preview_tactico = pg.image.load("assets\sprites\players\Tactico\preview.png").convert_alpha() 
imp_sps_tac_idle= pg.image.load("assets\sprites\players\Tactico\idle.png").convert_alpha() #placeholder para el sprite intangible
imp_sps_tac_hab= pg.image.load("assets\sprites\players\Tactico\especial.png").convert_alpha() #placeholder para el sprite intangible de habilidad
imp_sps_tac_walk= pg.image.load("assets\sprites\players\Tactico\walk.png").convert_alpha() #placeholder para el sprite intangible de correr
imp_sps_tac_death=pg.image.load("assets\sprites\players\Tactico\Death.png").convert_alpha() #placeholder para el sprite intangible de correr

#---kamikaze---
preview_kamikaze = pg.image.load("assets\sprites\players\Kamikaze\preview.png").convert_alpha() 
imp_sps_kam_idle= pg.image.load("assets\sprites\players\Kamikaze\idle.png").convert_alpha() #placeholder para el sprite intangible
imp_sps_kam_hab= pg.image.load("assets\sprites\players\Kamikaze\especial.png").convert_alpha() #placeholder para el sprite intangible de habilidad
imp_sps_kam_walk= pg.image.load("assets\sprites\players\Kamikaze\walk.png").convert_alpha() #placeholder para el sprite intangible de correr
imp_sps_kam_death=pg.image.load("assets\sprites\players\Kamikaze\death.png").convert_alpha() #placeholder para el sprite intangible de correr

#------POWERUPS-----------------
Escudo= pg.image.load("assets\Textures\escudo.png").convert_alpha() #sprite del powerup escudo
pg.transform.scale(Escudo, (32, 32)) #redimensiona el sprite del escudo a 42x42

Velocidad= pg.image.load("assets\Textures\Bota.png").convert_alpha() #sprite del powerup velocidad
pg.transform.scale(Velocidad, (32, 32)) #redimensiona el sprite de la velocidad a 42x42

bombini= pg.image.load("assets\Textures\Bomba.png").convert_alpha() #sprite del powerup bombini
pg.transform.scale(bombini, (32, 32)) #redimensiona el sprite

powerups_img = {"escudo": Escudo,"velocidad": Velocidad, "bomba": bombini }


#-----------------------llave y candado------------------------------
llave_candado_sps= pg.image.load("assets\Textures\llave_candado.png").convert_alpha() #sprite de la llave
spritesheet_llave_candad= SpriteSheet(llave_candado_sps) #crea una instancia de la clase SpriteSheet con el sprite de la llave
llave_img= spritesheet_llave_candad.get_image(0, 128, 192, 0.25, "black") #obtiene la imagen de la llave del spritesheet
candado_img= spritesheet_llave_candad.get_image(1, 128, 192, 0.25, "black") #obtiene la imagen del candado del spritesheet

#-----------------------SPRITESHEET DE JUGADORES ------------------------------
spritesheet_habilidades_prev= SpriteSheet (sps_habilidades)
spritecheet_items= SpriteSheet (sps_items)
spritesheet_powerups=SpriteSheet(sps_powerups)
spritesheet_nuke=SpriteSheet(sps_nuke) #spritesheet de la bomba nuclear

#Invencible 
spritesheet_idle_int = SpriteSheet(imp_sps_intangible_idle) #crea una instancia de la clase SpriteSheet con el sprite del jugador
spritesheet_habilidad_int = SpriteSheet(imp_sps_intalgible_hab) #crea una instancia de la clase SpriteSheet con el sprite de habilidad del jugador
spritesheet_walk_int = SpriteSheet(imp_sps_intangible_walk) #crea una instancia de la clase SpriteSheet con el sprite de correr del jugador
spritesheet_death_int = SpriteSheet(imp_sps_intangible_death) #crea una instancia de la clase SpriteSheet con el sprite de correr del jugador

#tactico
spritesheet_idle_tac = SpriteSheet(imp_sps_tac_idle) #crea una instancia de la clase SpriteSheet con el sprite del jugador
spritesheet_habilidad_tac = SpriteSheet(imp_sps_tac_hab) #crea una instancia de la clase SpriteSheet con el sprite de habilidad del jugador
spritesheet_walk_tac = SpriteSheet(imp_sps_tac_walk) #crea una instancia de la clase SpriteSheet con el sprite de correr del jugador
spritesheet_death_tac = SpriteSheet(imp_sps_tac_death) #crea una instancia de la clase SpriteSheet con el sprite de correr del jugador
#kamikaze
spritesheet_idle_kam= SpriteSheet(imp_sps_kam_idle) #crea una instancia de la clase SpriteSheet con el sprite del jugador
spritesheet_habilidad_kam = SpriteSheet(imp_sps_kam_hab) #crea una instancia de la clase SpriteSheet con el sprite de habilidad del jugador
spritesheet_walk_kam = SpriteSheet(imp_sps_kam_walk) #crea una instancia de la clase SpriteSheet con el sprite de correr del jugador
spritesheet_death_kam = SpriteSheet(imp_sps_kam_death) #crea una instancia de la clase SpriteSheet con el sprite de correr del jugador


Player_1= None

#ds
font_tit= pg.font.Font("fonts\\Upheavt.ttf",60)
font_tit1= pg.font.Font("fonts\\Upheavt.ttf",50)

#fonts pixeltype
font = pg.font.Font("fonts/Pixeltype.ttf", 35) #fuente para mostrar info de cada skin del player
font0= pg.font.Font("fonts/Pixeltype.ttf", 30) #fuente para mostrar info de cada skin del player
font1= pg.font.Font("fonts/Pixeltype.ttf", 50) #fuente para mostrar titulo de cada skin de player   
skin_seleccionada = 0                   #variable global para controlar la skin que selecciona en la aprte de seleccion de jugador (skin)
skin_viendo=0


##BOTONES GLOBALES 
boton_back= Boton (740,594,70,30,"Atras", "fonts/Pixeltype.ttf", 28,(133, 146, 158) ,(153, 163, 164))
boton_siguiente_opcion= Boton(300, 500, 150, 30, "Siguiente", "fonts/Pixeltype.ttf", 28, (44, 62, 80), (52, 73, 94 )) #"crea un boton de siguiente opcion (tiene que estar afuera por tipo int)
boton_seleccionar = Boton(300, 540, 150, 30, "Seleccionar", "fonts/Pixeltype.ttf", 28, (44, 62, 80), (52, 73, 94 ) ) #crea un boton de seleccionar
Boton_ingresar = Boton (320,320,150,30,"Empezar", "fonts/Pixeltype.ttf", 28,(133, 146, 158) ,(153, 163, 164))
Boton_mejores_p = Boton (320,360,150,30,"Ver Puntajes", "fonts/Pixeltype.ttf", 28,(133, 146, 158) ,(153, 163, 164))
Boton_opciones = Boton (320,400,150,30,"Opciones", "fonts/Pixeltype.ttf", 28,(133, 146, 158) ,(153, 163, 164))
Boton_creditos = Boton (100,594,130,30,"Ver Creditos", "fonts/Pixeltype.ttf", 28,(133, 146, 158) ,(153, 163, 164))
boton_aceptar_trato= Boton(300, 60, 150, 30, "Aceptar", "fonts/Pixeltype.ttf", 28, ("red"), ("green")) #crea un boton de aceptar trato
boton_comprar_vidas= Boton(300, 420, 210, 30, "+25 Vida (2 creditos)", "fonts/Pixeltype.ttf", 28, ("gray"), ("green")) #crea un boton de comprar vidas
boton_comprar_dano= Boton(300, 370, 210, 30, "+1 Dano (3 creditos)", "fonts/Pixeltype.ttf", 28, ("gray"), ("green")) #crea un boton de comprar dano
boton_comprar_pts= Boton(300, 320, 210, 30, "+1 credito (500 puntos)", "fonts/Pixeltype.ttf", 28, ("gray"), ("green")) #crea un boton de comprar puntos
boton_continuar_nivel= Boton(300, 470, 210, 30, "Siguiente nivel", "fonts/Pixeltype.ttf", 28, ("red"), ("green")) #crea un boton de continuar
boton_scoreboard_puntaje= Boton(300, 510, 210, 30, "Guardar", "fonts/Pixeltype.ttf", 28, (44, 62, 80), (52, 73, 94 )) #crea un boton de gaurdar_puntaje_en el json
boton_guardar_puntaje= Boton(300, 470, 210, 30, "Guardar Puntaje", "fonts/Pixeltype.ttf", 28, (44, 62, 80), (52, 73, 94 )) #crea un boton de continuar
anterior_puntaje_guardar=False
prev_siguiente = False #variable para controlar si se ha hecho clic en el botón de siguiente opción
prev_seleccion = False  #variable para controlar si se ha hecho clic en el botón de seleccionar
prev_ing=False
prev_mejor_p=False
prev_opc=False
prev_atras=False
prev_creditos=False
prev_aceptar_trato = False #variable para controlar si se ha hecho clic en el botón de aceptar trato
prev_comprar_vidas = False
prev_comprar_dano = False
prev_comprar_pts = False
prev_siguiente_nivel = False
#!PANTALLAS DE HABILIDAD 
escojio = False #variable para controlar que pantalla de habilidad se muestra
vidas_choice = 0 #vidas por bombas
bombas_choice = 0 #bombas por vidas
choice= 0

#----------------------MUSICA--------------------
musica_menu=pg.mixer.Sound("sounds\music\Main_menu.mp3")
musica_puntajes=pg.mixer.Sound("sounds\music\puntajes.mp3")
musica_creditos=pg.mixer.Sound("sounds\music\credits.mp3")
musica_seleccion_personaje=pg.mixer.Sound("sounds\music\player_selection.mp3")
musica_ending=pg.mixer.Sound("sounds\music\good_ending.mp3")
musica_compra=pg.mixer.Sound("sounds\music\compra.mp3")
musica_name_selection=pg.mixer.Sound("sounds\music\\name_selection.mp3")
musica_cambio_nivel=pg.mixer.Sound("sounds\sfx\\cambio_lvl.mp3")
#----------------------------SFX------------------------------
sfx_bomba= pg.mixer.Sound("sounds\sfx\Bomba.mp3") #sonido de la bomba
#-----------------------SPRITES------------------------------
#Obstaculos
sps_obstacles = pg.image.load("assets\Textures\Bricks.png")
spritesheet_Obstaculos = SpriteSheet(sps_obstacles)
Obstaculo_I = spritesheet_Obstaculos.get_image(1,64,64,0.75,'white')
Obstaculo_R = spritesheet_Obstaculos.get_image(4,64,64,0.75,'white')

#Floor
sps_floor = pg.image.load("assets\Textures\Floor.png")
spritesheet_Floor = SpriteSheet(sps_floor)
Floor_corner0 = spritesheet_Floor.get_image(0,64,64,0.75,'white')
Floor_corner1 = pg.transform.rotate(Floor_corner0,90)
Floor_corner2 = pg.transform.rotate(Floor_corner0,180)
Floor_corner3 = pg.transform.rotate(Floor_corner1,180)
Floor_up = spritesheet_Floor.get_image(1,64,64,0.75,'white')
Floor_down = pg.transform.rotate(Floor_up,180)
Floor_lside = spritesheet_Floor.get_image(3,64,64,0.75,'white')
Floor_rside = pg.transform.rotate(Floor_lside,180)
Floor_nothing = spritesheet_Floor.get_image(4,64,64,0.75,'white')

#Enemigos
sps_perro_cañon = pg.image.load("assets\sprites\enemies\perro_canon\Walk.png")
spritesheet_perro_cañon = SpriteSheet(sps_perro_cañon)
#Perro cañon muerte
sps_perro_muerte = pg.image.load("assets\sprites\enemies\perro_canon\Death.png")
spritesheet_perro_muerte = SpriteSheet(sps_perro_muerte)

#Moreno
sps_moreno = pg.image.load("assets\sprites\enemies\moreno\Walk.png")
spritesheet_Moreno = SpriteSheet(sps_moreno)
#MORENO MUERTE
sps_moreno_muerte = pg.image.load("assets\sprites\enemies\moreno\Death.png")
spritesheet_moreno_muerte = SpriteSheet(sps_moreno_muerte)
#MORENO HURT
sps_moreno_discreto = pg.image.load("assets\sprites\enemies\moreno\Hurt.png")
spritesheet_moreno_hurt = SpriteSheet(sps_moreno_discreto)

#Volador
sps_volador = pg.image.load("assets\sprites\enemies\Volador\Idle.png")
spritesheet_volador = SpriteSheet(sps_volador)
#Volador Ataque
sps_v_a = pg.image.load("assets\sprites\enemies\Volador\Attack1.png")
spritesheet_v_a = SpriteSheet(sps_v_a)
#Volador muerte
sps_volador_muerte = pg.image.load("assets\sprites\enemies\Volador\BOOM_death.png")
spritesheet_volador_muerte = SpriteSheet(sps_volador_muerte)

#Trampa
sps_trampa = pg.image.load("assets\Textures\Trap.png")
spritesheet_trampa = SpriteSheet(sps_trampa)


Hielito_xd = pg.image.load("assets\Textures\hielo.png")
Hielo_xd = pg.transform.scale(Hielito_xd, (48, 48))
#Kugel boss
#_______________________________________________________________________
#Attack
sps_attack = pg.image.load("assets\sprites\enemies\Boss\Attack.png")
spritesheet_boss_attack = SpriteSheet(sps_attack)

#Bullet
sps_bullet = pg.image.load("assets\sprites\enemies\Boss\Bullet.png")
spritesheet_BB = SpriteSheet(sps_bullet)

#Death 
sps_boss_death = pg.image.load("assets\sprites\enemies\Boss\Death.png")
spritesheet_boss_death = SpriteSheet(sps_boss_death)

#Fly 
sps_fly = pg.image.load("assets\sprites\enemies\Boss\Fly_up.png")
spritesheet_boss_fly = SpriteSheet(sps_fly)

#Hurt
sps_boss_hurt = pg.image.load("assets\sprites\enemies\Boss\Hurt.png")
spritesheet_boss_hurt = SpriteSheet(sps_boss_hurt)

#Idle
sps_boss_idle = pg.image.load("assets\sprites\enemies\Boss\Idle.png")
spritesheet_boss_idle = SpriteSheet(sps_boss_idle)

#Walk attack
sps_walk_attack_boss = pg.image.load("assets\sprites\enemies\Boss\Walk_attack.png")
spritesheet_walk_attack_boss = SpriteSheet(sps_walk_attack_boss)

#walk boss
sps_walk_boss = pg.image.load("assets\sprites\enemies\Boss\Walk.png")
spritesheet_walk_boss = SpriteSheet(sps_walk_boss)

#_________________________________________________________________________________

#Bomba
sps_bomba = pg.image.load("assets\Textures\Bomba\Bomba.png")
spritesheet_Bomba = SpriteSheet(sps_bomba)

#Explosion_Centro:
sps_exp_centro = pg.image.load("assets\Textures\Bomba\explosion_c.png")
spritesheet_exp_c = SpriteSheet(sps_exp_centro)

#Explosion Borde:
sps_exp_borde = pg.image.load("assets\Textures\Bomba\explosion_b.png")
spritesheet_exp_b = SpriteSheet(sps_exp_borde)
#Explosion Lado:
sps_exp_lado = pg.image.load("assets\Textures\Bomba\explosion_l.png")
spritesheet_exp_l = SpriteSheet(sps_exp_lado)

#Bomba
sps_bomba_boss = pg.image.load("assets\sprites\enemies\Boss\Bomba\Bomba.png")
spritesheet_Bomba_boss = SpriteSheet(sps_bomba_boss)

#Explosion_Centro:
sps_exp_centro_boss = pg.image.load("assets\sprites\enemies\Boss\Bomba\explosion_c.png")
spritesheet_exp_c_boss = SpriteSheet(sps_exp_centro_boss)

#Explosion Borde:
sps_exp_borde_boss = pg.image.load("assets\sprites\enemies\Boss\Bomba\explosion_b.png")
spritesheet_exp_b_boss = SpriteSheet(sps_exp_borde_boss)
#Explosion Lado:
sps_exp_lado_boss = pg.image.load("assets\sprites\enemies\Boss\Bomba\explosion_l.png")
spritesheet_exp_l_boss = SpriteSheet(sps_exp_lado_boss)

#melee
sps_melee_boss = pg.image.load("assets\sprites\enemies\Boss\melee.png")
spritesheet_boss_melee = SpriteSheet(sps_melee_boss)


#--------------------------------------------------------FUNCIONES GET PLAYS---------------------------
def cargar_partidas() : 
     global RUTA_PLAYS 
     try :
          with open(RUTA_PLAYS, 'r', encoding='utf-8') as f:
               return json.load(f)
     except FileNotFoundError:
        return {"partidas": []}

def guardar_partida(data) : 
     global RUTA_PLAYS 
     with open(RUTA_PLAYS, 'w', encoding='utf-8') as f : 
          json.dump(data, f, indent=2, ensure_ascii=False)

def nueva_partida( usuario, puntaje, personaje, nivel):
    global RUTA_PLAYS
    data = cargar_partidas()
    partida = {
        "usuario": usuario,
        "puntaje": puntaje,
        "personaje": personaje,
        "nivel": nivel,
    }
    data["partidas"].append(partida)
    guardar_partida(data)

def get_partidas () :
    global jugadas
    data = cargar_partidas()
    for partida in data["partidas"]:
        usuario  = partida["usuario"]
        puntaje  = partida["puntaje"]
        nivel    = partida["nivel"]
        personaje= partida["personaje"]
        jugadas.append([f"{usuario:10s} | Puntaje: {puntaje:5d} | Nivel: {nivel:d} | Personaje: {personaje}"])

def dibujar_scoreboard(screen, partidas, font, x=50, y=50, line_height=35):
    for idx, p in enumerate(partidas):
        # Extraer campos con respaldo por si falta algo
        usuario   = str(p.get("usuario", "Desconocido"))
        puntaje   = int(p.get("puntaje", 0))
        nivel     = int(p.get("nivel", 0))
        personaje = str(p.get("personaje", "???"))

        linea = f"{idx+1}. {usuario:<12}  Puntaje: {puntaje:<5}  Nivel: {nivel:<2}  Personaje: {personaje}"
        texto = font.render(linea, True, (255, 255, 255))
        screen.blit(texto, (x, y + idx * line_height))
#------------------------------------------------------FUNCIONES SECUNDARIAS PARA NIVEL---------------------------------------- 
#Funcion que ha partir de la matriz lee las posiciones iniciales 
def save_positions(screen):
        global obstacles, matriz, Lista_Enemigos_1, obstacles_R, Lista_Enemigos_2, Lista_Enemigos_3, Lista_Boss, traps, hielo
        for fil in range(len(matriz)):
             for col in range(len(matriz[fil])):
                  if matriz[fil][col] == '#': 
                       texture = Obstaculo_I
                       obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                       obstacles += [obs]
                       
                  if matriz[fil][col] == '*':
                       texture = Obstaculo_R
                       obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                       obstacles += [obs]
                       obstacles_R += [obs]

                  if matriz[fil][col] == 'Q':
                       trap = Trampa(screen,(col*48), (fil*48),spritesheet_trampa,13, 32,32,1.5,'black')
                       traps += [trap]

                  if matriz[fil][col] == 'H':
                       texture = Hielo_xd
                       obs = Hielo(screen, (col*48),(fil*48) , texture)
                       hielo += [obs]
                       

                  if matriz[fil][col] == 1:
                       Enemigo_perro = Enemigos(screen, (col*48), (fil*48), 1.1, spritesheet_perro_cañon, spritesheet_perro_muerte, 3, 48, 48, 1, 'black', False, random.randint(0,3))
                       Lista_Enemigos_1 += [Enemigo_perro]

                  if matriz[fil][col] == 2:
                       Enemigo_Moreno = Enemigo2(screen, (col*48), (fil*48), 1.1, spritesheet_Moreno, spritesheet_moreno_muerte,spritesheet_moreno_hurt, 5, 48, 48, 1, 'black', False, random.randint(0,3),50) 
                       Lista_Enemigos_2 += [Enemigo_Moreno]

                  if matriz[fil][col] == 3:
                       Enemigo_Volador = Enemigo3(screen, (col*48), (fil*48), 1.3, spritesheet_volador, spritesheet_volador_muerte,spritesheet_v_a, spritesheet_v_a,3, 72, 72, 0.8, 'black', False, random.randint(0,3),70) 
                       Lista_Enemigos_3 += [Enemigo_Volador]

                  if matriz[fil][col] == 4:
                       Enemigo_Boss = Boss(screen, (col*48), (fil*48), 2, spritesheet_walk_boss, spritesheet_boss_death,spritesheet_boss_attack, spritesheet_boss_hurt,3, 96, 96, 3, 'black', False, random.randint(0,3),3000,spritesheet_boss_fly,spritesheet_walk_attack_boss,spritesheet_boss_idle,spritesheet_boss_melee)
                       Lista_Boss += [Enemigo_Boss]
                                    
def generar_powerups(screen, imagenes, map_cols, map_rows):
    powerups = []
    n_items = random.randint(1, 12)

    for _ in range(n_items):
        # Elegir tipo
        tipo = random.choice(["velocidad", "escudo", "bomba"])
        sprite = imagenes[tipo]

        # Elegir celda al azar
        col = random.randrange(map_cols)
        row = random.randrange(map_rows)

        # Centro de la celda
        x = col * CELL_SIZE -6
        y = row * CELL_SIZE -9

        # Crear y almacenar el power-up
        item = Item(screen, x, y, sprite, tipo)
        powerups.append(item)

    return powerups

def encontrar_posiciones_llave(matriz, tile_width, tile_height):

    posiciones = []
    for fila_idx, fila in enumerate(matriz):
        for col_idx, celda in enumerate(fila):
            if celda == '*':
                x = col_idx * tile_width
                y = fila_idx * tile_height
                posiciones.append((x, y))
    return posiciones

def ubicar_llave(matriz, tile_width, tile_height):
    global llave_img
    posiciones = encontrar_posiciones_llave(matriz, tile_width, tile_height)
    if not posiciones:
        raise ValueError("No hay ningún bloque '*' donde poner la llave.")
    x, y = random.choice(posiciones)
    return llave_candado(x, y, True, False, llave_img)

#Este genera las texturas inamovibles, los enemigos se dibujan y se tratan dentro de su propia clase
def generate(screen):
    global obstacles, matriz, powerups, nivel, llave, candado, estado, start_time_pantalla, global_fade, puntaje_final, puntaje_nivel, nivel, pos_jugador, FOV_RADIUS, hielo
    
    for fil in range(len(matriz)):
        for col in range(len(matriz[fil])):
            x = col * 48
            y = fil * 48
            celda = matriz[fil][col]

            if celda in (0,1,8,9,'u','d','l','r','w','a','s','f','c','U','D','L','R','W','A','S','D','F','C',2,3,4,'Q'):
                if fil == 0 and col == 0:
                    texture = Floor_corner0
                elif fil == 0 and col == 16:
                    texture = Floor_corner3
                elif fil == 10 and col == 16:
                    texture = Floor_corner2
                elif fil == 10 and col == 0:
                    texture = Floor_corner1
                elif fil == 0:
                    texture = Floor_up
                elif col == 0:
                    texture = Floor_lside
                elif col == 16:
                    texture = Floor_rside
                elif fil == 10:
                    texture = Floor_down
                else:
                    texture = Floor_nothing

                obs = Obstaculo(screen, x, y, texture)
                if nivel != 1:
                    obs.draw()
                if nivel == 1:
                    try:
                         if is_in_fov_circle(pos_jugador,(obs.x,obs.y),FOV_RADIUS):
                              obs.draw()
                    except:
                         pass
                     

    if powerups is not None:
          for item in powerups:
               if nivel != 1:
                    screen.blit(item.spritesheet, (item.x, item.y))
               if nivel == 1:
                    try:
                         if is_in_fov_circle(pos_jugador,(item.x, item.y),FOV_RADIUS):
                              screen.blit(item.spritesheet, (item.x, item.y))
                    except:
                         pass
               
               if Player_1.colisiona_con(item):
                    if item.tipo == "velocidad":
                         Player_1.items["velocidad"] = Player_1.items.get("velocidad", 0) + 1
                    elif item.tipo == "escudo":
                         Player_1.items["escudo"] = Player_1.items.get("escudo", 0) + 1
                    elif item.tipo == "bomba":
                         Player_1.items["bombas"] = Player_1.items.get("bombas", 0) + 1
                    powerups.remove(item)
    if llave:
        if nivel != 1:
                    game_surface.blit(llave_img, (llave.x+10, llave.y))
        if nivel == 1:
                    try:
                         if is_in_fov_circle(pos_jugador,(llave.x+10, llave.y),FOV_RADIUS):
                              game_surface.blit(llave_img, (llave.x+10, llave.y))
                    except:
                         pass
        
        if Player_1.colisiona_con(llave):
            Player_1.tiene_llave = True
            llave=None #remueve la llave de la pantalla una vez que el jugador la recoge
    if candado:
        if nivel != 1:
                    game_surface.blit(candado_img, (candado.x+10, candado.y))
        if nivel == 1:
                    try:
                         if is_in_fov_circle(pos_jugador,(candado.x+10, candado.y),FOV_RADIUS):
                              game_surface.blit(candado_img, (candado.x+10, candado.y))
                    except:
                         pass
        
        if Player_1.colisiona_con(candado) and Player_1.tiene_llave:
            candado = None
            puntaje_final= puntaje_nivel + 500 #puntaje por abrir el candado
            estado ="comprar_powerups" if nivel < 3 else "good_ending"
            start_time_pantalla = pg.time.get_ticks()
            global_fade = False  # Reiniciar el fade global

    Player_1.velocidad=Player_1.base_speed

    for fil in range(len(matriz)):
        for col in range(len(matriz[fil])):
            x = col * 48
            y = fil * 48
            celda = matriz[fil][col]

            if celda == '#':
                texture = Obstaculo_I
                obs = Obstaculo(screen, x, y, texture)
                if nivel != 1:
                    obs.draw()
                if nivel == 1:
                    try:
                         if is_in_fov_circle(pos_jugador,(obs.x,obs.y),FOV_RADIUS):
                              obs.draw()
                    except:
                         pass
                

            elif celda == '*':
                texture = Obstaculo_R
                obs = Obstaculo(screen, x, y, texture)
                if nivel != 1:
                    obs.draw()
                if nivel == 1:
                    try:
                         if is_in_fov_circle(pos_jugador,(obs.x,obs.y),FOV_RADIUS):
                              obs.draw()
                    except:
                         pass

            if celda == 'H':
                       texture = Hielo_xd
                       obs = Hielo(screen, (col*48),(fil*48) , texture)
                       obs.draw()
    for hielos in hielo : 
         if Player_1.colisiona_con(hielos):
              Player_1.velocidad=0.5


#funciones para la generacion y manejo de bombas
def bombastic_pos (screen): #guarda posicion de manejo de bombas 
     global lista_B, lista_E, bomba_in_bounds, lista_EL, lista_B_Boss, lista_E_Boss, lista_EL_Boss
     for fil in range(len(matriz)):
             for col in range(len(matriz[fil])):
                  if matriz[fil][col] == 8:
                       Bomba_R = Bomba_Matriz(screen, (col*48), (fil*48), spritesheet_Bomba, 5, 64, 64, 0.75, 'black',True)
                       lista_B += [Bomba_R]
                       matriz[fil][col] = 0
                  if matriz[fil][col] == 9:
                       Exp_R = Explosion_Matriz(screen, (col*48), (fil*48), spritesheet_exp_c, 5, 64, 64, 0.75, 'black',True)
                       lista_E += [Exp_R]
                       matriz[fil][col] = 0
                       

                  if matriz[fil][col] in ('u','l','d','r'):
                       EXP_RL = Explosion_Matriz_Lados(screen, (col*48), (fil*48), spritesheet_exp_l, 5, 64, 64, 0.75, 'black',True,matriz[fil][col])
                       lista_EL += [EXP_RL]
                       

                  if matriz[fil][col] in ('w','a','s','f'):
                       EXP_RL = Explosion_Matriz_Lados(screen, (col*48), (fil*48), spritesheet_exp_b, 5, 64, 64, 0.75, 'black',True,matriz[fil][col])
                       lista_EL += [EXP_RL]

                  if matriz[fil][col] == 'c':
                       EXP_RL = Explosion_Matriz_Lados(screen, (col*48), (fil*48), spritesheet_exp_c, 5, 64, 64, 0.75, 'black',True,matriz[fil][col])
                       lista_EL += [EXP_RL]    

                  if matriz[fil][col] == 6:
                       Bomba_R = Bomba_Matriz_boss(screen, (col*48), (fil*48), spritesheet_Bomba_boss, 5, 64, 64, 0.75, 'black',True)
                       lista_B_Boss += [Bomba_R]
                       matriz[fil][col] = 0

                  if matriz[fil][col] == 7:
                       Exp_R = Explosion_Matriz_boss(screen, (col*48), (fil*48), spritesheet_exp_c_boss, 5, 64, 64, 0.75, 'black',True)
                       lista_E_Boss += [Exp_R]
                       matriz[fil][col] = 0

                  if matriz[fil][col] in ('U','L','D','R'):
                       EXP_RL = Explosion_Matriz_Lados_Boss(screen, (col*48), (fil*48), spritesheet_exp_l_boss, 5, 64, 64, 0.75, 'black',True,matriz[fil][col])
                       lista_EL_Boss += [EXP_RL]
                       

                  if matriz[fil][col] in ('W','A','S','D'):
                       EXP_RL = Explosion_Matriz_Lados_Boss(screen, (col*48), (fil*48), spritesheet_exp_b_boss, 5, 64, 64, 0.75, 'black',True,matriz[fil][col])
                       lista_EL_Boss += [EXP_RL]

                  if matriz[fil][col] == 'C':
                       EXP_RL = Explosion_Matriz_Lados_Boss(screen, (col*48), (fil*48), spritesheet_exp_c_boss, 5, 64, 64, 0.75, 'black',True,matriz[fil][col])
                       lista_EL_Boss += [EXP_RL]    
          
     if lista_B == []:
          bomba_in_bounds = False

def limpiar():
     global matriz
     for fil in range(len(matriz)):
             for col in range(len(matriz[fil])):
                       if matriz[fil][col] in ('u','l','d','r','w','a','s','f','c'):
                            matriz[fil][col] = 0
def limpiar_boss():
     global matriz
     for fil in range(len(matriz)):
             for col in range(len(matriz[fil])):
                       if matriz[fil][col] in ('U','D','L','R','W','A','S','D','F','C'):
                            matriz[fil][col] = 0
                       
def bombastic_hitbox ():
     global star_up, star_right, star_left, star_down,puntaje_nivel, obstacles, obstacles_R
     for bomba_boss in lista_B_Boss:
          bomba_boss.auto_animate()
     for exp_b in lista_E_Boss:
          exp_b.auto_animate()
          if Player_1.colisiona_con(exp_b) and not Player_1.item_en_uso["escudo"]:
               Player_1.vida-=0.25
          for obsR in obstacles_R:
               if Explosion_Matriz_boss.colisiona_con(exp_b, obsR):
                   matriz[int(obsR.y/48)][int(obsR.x/48)] = 0
                   obstacles_R.remove(obsR)
                   obstacles.remove(obsR)
          
    
          x = exp_b.x // 48
          y = exp_b.y // 48
          max_filas = len(matriz)
          max_cols  = len(matriz[0])

          # ARRIBA
          
          for i in range(1, Fuerza_exp_boss + 1):
               if not exp_b.star_up:
                    yi, xi = y - i, x
                    if not (0 <= yi < max_filas):
                         yi0 = y - (i - 1)
                         if 0 <= yi0 < max_filas:
                              if  yi0 != y:
                                   matriz[yi0][xi] = 'W'
                              else:
                                   matriz[yi0][xi] = 'C'
                         break

                    celda = matriz[yi][xi]
                    if celda == '*':
                         matriz[yi][xi] = 'U'
                         exp_b.star_up = True
                         
                         break
                    if celda in ('#', 6, 7):
                         break
                    matriz[yi][xi] = 'W' if i == Fuerza_exp_boss else 'U'
               

          # ABAJO
          for i in range(1, Fuerza_exp_boss + 1):
               if not exp_b.star_down:
                    yi, xi = y + i, x
                    if not (0 <= yi < max_filas):
                         yi0 = y + (i - 1)
                         if 0 <= yi0 < max_filas:
                              if yi0 != y:
                                   matriz[yi0][xi] = 'S'
                              else:
                                   matriz[yi0][xi] = 'C'
                         break

                    celda = matriz[yi][xi]
                    if celda == '*':
                         matriz[yi][xi] = 'D'
                         exp_b.star_down = True
                         break
                    if celda in ('#', 6, 7):
                         break
                    matriz[yi][xi] = 'S' if i == Fuerza_exp_boss else 'D'

          # DERECHA
          for i in range(1, Fuerza_exp_boss + 1):
               if not exp_b.star_right:
                    yi, xi = y, x + i
                    if not (0 <= xi < max_cols):
                         xi0 = x + (i - 1)
                         if 0 <= xi0 < max_cols:
                              if xi0 != x:
                                   matriz[yi][xi0] = 'F'
                              else:
                                   
                                   matriz[yi][xi0] = 'C'
                         break

                    celda = matriz[yi][xi]
                    if celda == '*':
                         matriz[yi][xi] = 'R'
                         exp_b.star_right = True
                         break
                    if celda in ('#', 6, 7):
                         break
                    matriz[yi][xi] = 'F' if i == Fuerza_exp_boss else 'R'

          # IZQUIERDA
          for i in range(1, Fuerza_exp_boss + 1):
               if not exp_b.star_left:
                    yi, xi = y, x - i
                    if not (0 <= xi < max_cols):
                         xi0 = x - (i - 1)
                         if 0 <= xi0 < max_cols:
                              if xi0 != x:
                                   matriz[yi][xi0] = 'A'
                              else:
                                   matriz[yi][xi0] = 'C'
                         break

                    celda = matriz[yi][xi]
                    if celda == '*':
                         matriz[yi][xi] = 'L'
                         exp_b.star_left = True
                         break
                    if celda in ('#', 6, 7):
                         break
                    matriz[yi][xi] = 'A' if i == Fuerza_exp_boss else 'L'

     for exp_l_b in lista_EL_Boss:
               
               exp_l_b.auto_animate()
               if Player_1.colisiona_con(exp_l_b) and not Player_1.item_en_uso["escudo"]:
                    Player_1.vida-=0.25
               matriz[exp_l_b.y//48][exp_l_b.x//48] = 0
               for obsR in obstacles_R:  
                    if Explosion_Matriz_Lados_Boss.colisiona_con(exp_l_b, obsR):
                         matriz[int(obsR.y/48)][int(obsR.x/48)] = 0
                         obstacles_R.remove(obsR)
                         obstacles.remove(obsR)

               limpiar_boss()

     for bomba in lista_B:
          bomba.auto_animate()
     for exp in lista_E:
          exp.auto_animate()

          for obsR in obstacles_R:
               if Explosion_Matriz.colisiona_con(exp, obsR):
                   matriz[int(obsR.y/48)][int(obsR.x/48)] = 0
                   obstacles_R.remove(obsR)
                   obstacles.remove(obsR)
          for enemies in Lista_Enemigos_1:
              if Explosion_Matriz.colisiona_con(exp, enemies):
                   puntaje_nivel+=1
                   enemies.animacion_muerte()
          for ene_2 in Lista_Enemigos_2:
               if Explosion_Matriz.colisiona_con(exp,ene_2):
                    if ene_2.vida <= 0:
                         
                         ene_2.animacion_muerte()
                    else:
                         ene_2.vida -= 1
                         puntaje_nivel+=1
                         ene_2.animacion_hurt()
          for ene_3 in Lista_Enemigos_3:
               if Explosion_Matriz.colisiona_con(exp,ene_3):
                    if ene_3.vida <= 0:
                         puntaje_nivel+=3
                         ene_3.animacion_muerte()
                         
                    else:
                         ene_3.vida -= 1
                         puntaje_nivel+=1
                         ene_3.animacion_hurt()
          for boss in Lista_Boss:
               if Explosion_Matriz.colisiona_con(exp,boss):
                    if boss.vida <= 0:
                         boss.animacion_muerte()
                         puntaje_nivel+=10
                         boss.calculo_renal()
                    else:
                         boss.vida -= 5 #daño al boss
                         puntaje_nivel+=5
                         boss.time = pg.time.get_ticks()
                         boss.animacion_hurt()

          
          
          if Player_1.colisiona_con(exp) and not Player_1.item_en_uso["escudo"]:
               Player_1.vida-=0.25
          
    
          x = exp.x // 48
          y = exp.y // 48
          max_filas = len(matriz)
          max_cols  = len(matriz[0])

          # ARRIBA
          
          for i in range(1, Fuerza_exp + 1):
               if not exp.star_up:
                    yi, xi = y - i, x
                    if not (0 <= yi < max_filas):
                         yi0 = y - (i - 1)
                         if 0 <= yi0 < max_filas:
                              if  yi0 != y:
                                   matriz[yi0][xi] = 'w'
                              else:
                                   matriz[yi0][xi] = 'c'
                         break

                    celda = matriz[yi][xi]
                    if celda == '*':
                         matriz[yi][xi] = 'u'
                         exp.star_up = True
                         
                         break
                    if celda in ('#', 9, 8):
                         break
                    matriz[yi][xi] = 'w' if i == Fuerza_exp else 'u'
               

          # ABAJO
          for i in range(1, Fuerza_exp + 1):
               if not exp.star_down:
                    yi, xi = y + i, x
                    if not (0 <= yi < max_filas):
                         yi0 = y + (i - 1)
                         if 0 <= yi0 < max_filas:
                              if yi0 != y:
                                   matriz[yi0][xi] = 's'
                              else:
                                   matriz[yi0][xi] = 'c'
                         break

                    celda = matriz[yi][xi]
                    if celda == '*':
                         matriz[yi][xi] = 'd'
                         exp.star_down = True
                         break
                    if celda in ('#', 9, 8):
                         break
                    matriz[yi][xi] = 's' if i == Fuerza_exp else 'd'

          # DERECHA
          for i in range(1, Fuerza_exp + 1):
               if not exp.star_right:
                    yi, xi = y, x + i
                    if not (0 <= xi < max_cols):
                         xi0 = x + (i - 1)
                         if 0 <= xi0 < max_cols:
                              if xi0 != x:
                                   matriz[yi][xi0] = 'f'
                              else:
                                   
                                   matriz[yi][xi0] = 'c'
                         break

                    celda = matriz[yi][xi]
                    if celda == '*':
                         matriz[yi][xi] = 'r'
                         exp.star_right = True
                         break
                    if celda in ('#', 9, 8):
                         break
                    matriz[yi][xi] = 'f' if i == Fuerza_exp else 'r'

          # IZQUIERDA
          for i in range(1, Fuerza_exp + 1):
               if not exp.star_left:
                    yi, xi = y, x - i
                    if not (0 <= xi < max_cols):
                         xi0 = x - (i - 1)
                         if 0 <= xi0 < max_cols:
                              if xi0 != x:
                                   matriz[yi][xi0] = 'a'
                              else:
                                   matriz[yi][xi0] = 'c'
                         break

                    celda = matriz[yi][xi]
                    if celda == '*':
                         matriz[yi][xi] = 'l'
                         exp.star_left = True
                         break
                    if celda in ('#', 9, 8):
                         break
                    matriz[yi][xi] = 'a' if i == Fuerza_exp else 'l'

     for exp_l in lista_EL:
          exp_l.auto_animate()
          if Player_1.colisiona_con(exp_l) and not Player_1.item_en_uso["escudo"]:
               Player_1.vida-=0.25

          matriz[exp_l.y//48][exp_l.x//48] = 0
          for obsR in obstacles_R:
               if Explosion_Matriz_Lados.colisiona_con(exp_l, obsR):
                   matriz[int(obsR.y/48)][int(obsR.x/48)] = 0
                   obstacles_R.remove(obsR)
                   obstacles.remove(obsR)
          for enemies in Lista_Enemigos_1:
              if Explosion_Matriz_Lados.colisiona_con(exp_l, enemies):
                   puntaje_nivel+=1
                   enemies.animacion_muerte()
          for ene_2 in Lista_Enemigos_2:
               if Explosion_Matriz.colisiona_con(exp_l,ene_2):
                    if ene_2.vida <= 0:
                         puntaje_nivel+=2
                         ene_2.animacion_muerte()
                    else:
                         ene_2.vida -= 1
                         puntaje_nivel+=1
                         ene_2.animacion_hurt()
          for ene_3 in Lista_Enemigos_3:
               if Explosion_Matriz.colisiona_con(exp_l,ene_3):
                    if ene_3.vida <= 0:
                         puntaje_nivel+=3
                         ene_3.animacion_muerte()
                    else:
                         ene_3.vida -= 1
                         puntaje_nivel+=1
                         ene_3.animacion_hurt()

          for boss in Lista_Boss:
               if Explosion_Matriz.colisiona_con(exp_l,boss):
                    if boss.vida <= 0:
                         boss.animacion_muerte()
                         puntaje_nivel+=10
                         boss.calculo_renal()
                    else:
                         
                         boss.vida -= 1
                         puntaje_nivel+=5
                         print(boss.vida)
                         boss.time = pg.time.get_ticks()
                         boss.animacion_hurt()

          limpiar()          
#Funcion para leer la matriz de nivel
def leer_archivo(path):
        archivo = open(path, 'r')
        contenido = archivo.read()
        archivo.close()
        return contenido

def init (nivel):
        global matriz
        texto_nivel = fr"games\\levels\\Nivel_{nivel}.txt"
        matriz = eval(leer_archivo(texto_nivel))
Enemigo_perro = Enemigos(screen, (0), (0), 1.1, spritesheet_perro_cañon, spritesheet_perro_muerte, 3, 48, 48, 0, 'black', False, random.randint(0,3)) #enemigo fantasma para q no explote todo xd
Lista_Enemigos_1 += [Enemigo_perro]
B_1 = Bomba(game_surface, 0, 0, spritesheet_Bomba, 5, 64, 64, 0.75, 'black',False) #Para la habilidad del tactico
E_1 = Explosion(game_surface, 0, 0, spritesheet_nuke, 20, 240, 150, 0.75, 'black',False) #Para la habilidad del tactico

#!---------------------------------------------EFECTOS ESPECIALES :o --------------------------------
def bg_men_parallax(): 
    global fondo_p_men, pos_par_men
    parallax_speeds = [0.1, 0.002, 0.2, 0.3, 0.4, 1.5 ]
    
    # Dibujar capas desde la más lejana (0) a la más cercana (6)
    for i in range (len (fondo_p_men)) :
        # Calcular nueva posición (movimiento infinito)
        pos_par_men[i] -= parallax_speeds[i]
        img= pg.transform.scale (fondo_p_men[i],(fondo_p_men[i].get_width()*0.25,fondo_p_men[i].get_height()*0.25) if 0<i<5  else((fondo_p_men[i].get_width()*0.55,fondo_p_men[i].get_height()*0.55) ))
        
        # Reiniciar posición cuando la imagen sale completamente de la pantalla
        if pos_par_men[i] <= -img.get_width():
            pos_par_men[i] = 0
        
        # Dibujar dos copias para el efecto de scroll infinito
        screen.blit(img, (pos_par_men[i], (0 )))
        screen.blit(img, (pos_par_men[i] + img.get_width(), 0))
def bg_opc_parallax():
    global fondos_p_op
    factores = [0.1, 0.3, 0.5, 0.7]

    mouse_pos = pg.mouse.get_pos()   
    mouse_x, mouse_y = mouse_pos
    
    # Calcular desplazamiento relativo al centro
    rel_x = (mouse_x - 816 // 2) / (816 // 2)
    rel_y = (mouse_y - 624 // 2) / (624 // 2)
    
    # Dibujar capas desde la más lejana (0) a la más cercana (3)
    for i, fondo in enumerate(fondos_p_op):
        # Calcular desplazamiento para esta capa
        fondo=pg.transform.scale(fondo, (1400,780))
        offset_x = rel_x * factores[i] * 100
        offset_y = rel_y * factores[i] * 100
        
        # Posición de dibujo (centrada con offset)
        pos_x = (816 - fondo.get_width()) // 2 + offset_x
        pos_y = (624 - fondo.get_height()) // 2 + offset_y
        
        screen.blit(fondo, (pos_x, pos_y))
    
def fade_in_from_white(duration_ms=400):
    # Capturar la escena actual como fondo estático
    background = screen.copy()
    
    overlay = pg.Surface(screen.get_size(), pg.SRCALPHA)
    overlay.fill((255, 255, 255))
    start_time = pg.time.get_ticks()
    clock = pg.time.Clock()
    
    running = True
    while running:
        screen.blit(background ,(0,0))
        elapsed = pg.time.get_ticks() - start_time
        progress = min(1, elapsed / duration_ms)
        
        if progress >= 1:
            alpha = 0
            running = False
        else :
            alpha = 255-int(255 * progress)
            #print (alpha)
        
        overlay.set_alpha(alpha)
        screen.blit(overlay, (0, 0))
        pg.display.flip()
        
        # Manejo de eventos sin bloquear
        for evt in pg.event.get():
            if evt.type == pg.QUIT:
                pg.quit()
                sys.exit()
        
        clock.tick(60)

def animar_cuadro(screen,
                  target_size=(716, 524),
                  speed=20,
                  alpha=100,
                  reset=False):
    global global_cuadrado

    # Reinicia la animación si hace falta
    if reset or not hasattr(animar_cuadro, "size"):
        animar_cuadro.size = [0, 0]
        global_cuadrado = False

    # Obtén el tamaño actual
    w, h = animar_cuadro.size
    tw, th = target_size

    # Actualiza anchura y altura
    if w < tw:
        w = min(w + speed, tw)
    if h < th:
        h = min(h + speed, th)

    # Guarda el nuevo tamaño
    animar_cuadro.size = [w, h]

    # Cuando llegue al tope, activa la flag
    #if w == tw and h == th :
     #   global_cuadrado = True

    # Crea la superficie blanca semitransparente
    surf = pg.Surface((w, h), pg.SRCALPHA)
    surf.fill((24,24,24, alpha))

    # Centra y dibuja
    sw, sh = screen.get_size()
    x = (sw - w) // 2
    y = (sh - h) // 2
    screen.blit(surf, (x, y))

def star_wars_crawl(surface, text_lines, images, font, color, speed):
    if not hasattr(star_wars_crawl, "offset_y"):
        star_wars_crawl.offset_y = surface.get_height()

    star_wars_crawl.offset_y -= speed  # subir todo

    # Dibuja texto
    y = star_wars_crawl.offset_y
    center_x = surface.get_width() // 2
    for line in text_lines:
        text_surface = font.render(line, True, color)
        text_rect = text_surface.get_rect(center=(center_x, y))
        surface.blit(text_surface, text_rect)
        y += font.get_height() + 10  # espacio entre líneas

    # Dibuja imágenes moviéndose igual que el texto
    for img_surf, x_offset, y_offset in images:
        img_rect = img_surf.get_rect()
        img_x = (surface.get_width() // 2) + x_offset
        img_y = star_wars_crawl.offset_y + y_offset
        surface.blit(img_surf, (img_x, img_y))

def pantalla_habilidad_kam () : 
     global escojio, vidas_choice, bombas_choice, choice, prev_aceptar_trato
     #background = screen.copy()
     #screen.blit(background ,(0,0))
     surf = pg.Surface((816,200), pg.SRCALPHA)
     surf.fill((24,24,24, 200))  # Fondo semitransparente
     screen.blit(surf, (0,0))
     titulo= font.render("Los espiritus te dan este trato :", False, (202, 28, 28))
     screen.blit(titulo,(240,5))
     if not escojio :
          choice= random.choice([0,1]) #para elegir cual pantalla mostrar 
          vidas_choice= random.randint(1,3) #vidas por bombas
          bombas_choice= random.randint(1,10)
          escojio = True
     texto_bombas= font0.render(f"-{vidas_choice if choice==0 else bombas_choice} {'vidas por ' if choice==0 else 'bombas por '} x {bombas_choice if choice==0 else vidas_choice} {'bombas' if choice==0 else 'vidas'}", False, "white")
     screen.blit(texto_bombas,(270,30))

     texto_aceptas = font.render("Aceptas el trato ?", False, "white")
     screen.blit(texto_aceptas,(280,100))
     boton_aceptar_trato.draw(screen)
     if boton_aceptar_trato.check_click() and not prev_aceptar_trato:
          if choice == 0:
               Player_1.cant_vidas -= vidas_choice if Player_1.cant_vidas > vidas_choice else 0
               Player_1.items["bombas"] = Player_1.items.get("bombas", 0) + bombas_choice
          elif choice == 1:
               Player_1.items["bombas"] = Player_1.items.get("bombas", 0) - bombas_choice
               Player_1.cant_vidas += vidas_choice
          escojio = False
     prev_aceptar_trato = boton_aceptar_trato.check_click()

#!------------------------------------------------PANTALLAS PRINCIPALES-------------------------------------------------
def pantalla_titulo () :
     global global_fade, bara_texto, estado,prev_ing,prev_ing,prev_opc,prev_mejor_p
     bg_men_parallax()
     titulo1= font_tit.render("EL HOMBRE", False, "white")
     titulo2= font_tit.render("Que tiraba bombas", False, "white")
     titulo3 =font0.render("Proyecto 2 , IC-1801 - Tecnologico de Costa Rica", False,"gray")
     credit=font0.render("Steadman Murillo - Benjamin Ortiz  2025", False, "white")
     screen.blit (titulo1,(250,50))
     screen.blit(titulo2,(120,90))
     
     if not global_fade :
          fade_in_from_white ()
          global_fade=True
     #dibujo botones 
     click_empezar=Boton_ingresar.check_click()
     click_puntajes=Boton_mejores_p.check_click()
     click_opc=Boton_opciones.check_click()
     if click_empezar and not prev_ing :
          estado="seleccion_personaje"
          global_fade=False
     if click_puntajes and not prev_mejor_p :
          animar_cuadro(screen,reset=True)
          estado= "puntajes"
     if click_opc and not prev_opc : 
          animar_cuadro(screen,reset=True)
          estado="opciones"

     Boton_ingresar.draw(screen)
     Boton_mejores_p.draw(screen)
     Boton_opciones.draw(screen)
     screen.blit(credit,(5,605))
     screen.blit(titulo3,(200,150))
volumen = 1.0  # variable global
def pantalla_opciones() : 
     global global_cuadrado, prev_atras, estado, estado_anterior, volumen
     bg_men_parallax()
     if not global_cuadrado : 
          animar_cuadro(screen)
     click_back= boton_back.check_click() 
     texto_volumeen_musica = font0.render("Volumen de la musica", False, "white")
     screen.blit(texto_volumeen_musica, (120, 380))

     slider_rect = pg.Rect(100, 450, 300, 8)         # posición y tamaño de la barra
     pg.draw.rect(screen, (180, 180, 180), slider_rect)  # barra

     # dibuja el “handle” según el nivel actual
     handle_x = slider_rect.x + int(volumen * slider_rect.width)
     handle_rect = pg.Rect(handle_x - 6, slider_rect.y - 6, 12, slider_rect.height + 12)
     pg.draw.rect(screen, (220, 220, 220), handle_rect)

     # detectar click y mover handle (sin usar eventos dentro):
     if pg.mouse.get_pressed()[0]:
          mx, my = pg.mouse.get_pos()
          if slider_rect.collidepoint(mx, my):
               volumen = (mx - slider_rect.x) / slider_rect.width
               # actualiza volumen en el mixer de forma inmediata:
               pg.mixer.music.set_volume(volumen)
     if click_back and not prev_atras : 
          estado= "menu"
          global_cuadrado= False
     prev_atras= click_back
     boton_back.draw(screen)

def pantalla_puntajes() : 
     global prev_atras, estado, prev_creditos, global_cuadrado
     bg_opc_parallax() 
     if not global_cuadrado :
          animar_cuadro(screen)

     

     click_atras = boton_back.check_click ()
     click_creditos =Boton_creditos.check_click()
     if click_atras and not prev_atras : 
          estado= "menu"
          global_cuadrado= False
     if click_creditos and not prev_creditos : 
          estado="creditos"
          global_cuadrado= False
     prev_atras= click_atras
     prev_creditos=click_creditos


     titulo= font_tit1.render("TOP 5 ", False, "white")
     screen.blit(titulo,(340,70))
     boton_back.draw(screen)
     Boton_creditos.draw(screen)
     data=cargar_partidas()
     todas= data.get("partidas",[])
     mejores= sorted(todas, key=lambda p: p["puntaje"],reverse=True)
     max_display = min(len(mejores), 5)    #solo top5
     top_cinco = mejores[:max_display]
     dibujar_scoreboard(screen , top_cinco, font, x=100, y=150, line_height=40 )

def dibujar_gui() :
    global tiempo_juego, puntaje_nivel, estado, Lista_Boss, lista_pw_uso, puntaje_final, puntaje_nivel
    screen.fill((24,24,24))
    texto_tiempo=font0.render(f"Tiempo : {tiempo_juego.tiempo}", False , "white")
    texto_puntaje_nivel = font0.render(f"Puntaje : {puntaje_nivel}",False,"white")
    if Player_1.vida <= 1 : 
         Player_1.muerto=True

    
    default_pw = spritesheet_powerups.get_image(2, 64, 64, 1, "black")
    default_pw_p = spritesheet_powerups.get_image(2, 64, 64, 0.5, "black")
    if Player_1.muerto and Player_1.current_frame == Player_1.frames_muerte-1 : 
        if Player_1.cant_vidas <= 0:
          puntaje_final= puntaje_nivel 
          estado = "GameOver"
        else : 
             Player_1.cant_vidas-=1
             Player_1.vida= Player_1.vida_max_actual
             Player_1.muerto=False
             Player_1.x= 0
             Player_1.y= 0

    powerup_sprites = {"vida": [spritesheet_powerups.get_image(0, 64, 64, 1, "black"),spritesheet_powerups.get_image(0, 64, 64, 0.5, "black")],"dano": [spritesheet_powerups.get_image(1, 64, 64, 1, "black"),spritesheet_powerups.get_image(1, 64, 64, 0.5, "black")]}
    pw_uso_1 = default_pw
    pw_uso_2 = default_pw_p
    if len(lista_pw_uso) >= 1:
        nombre1 = lista_pw_uso[0]
        sprites  = powerup_sprites.get(nombre1)
        if sprites:
            pw_uso_1 = sprites[0]
        # Si hay un segundo power‑up, úsalo en la ranura 2
        if len(lista_pw_uso) == 2:
            nombre2 = lista_pw_uso[1]
            sprites2  = powerup_sprites.get(nombre2)
            if sprites2:
                pw_uso_2 = sprites2[1]

    # Ahora dibuja pw_uso_1 y pw_uso_2 donde corresponda en tu GUI
    vida_jugador=Healthbar_Player (73, 15, 110, 20, Player_1.vida,Player_1.vida_max_actual, heart_texture,Player_1.cant_vidas,font0)  # Dibuja la barra de salud del jugador
    vida_jugador.draw(screen)  # Dibuja la barra de salud en la superficie del juego
    vida_jugador.draw_atributes(screen)  # Dibuja los atributos de la barra de salud en la superficie del juego
    habilidad_jugador= HealthBar(73, 55, 110, 20, Player_1.barra_habilidad,100, (129, 133, 137), Player_1.color_habilidad)  # Dibuja la barra de habilidad del jugador
    vida_boss= HealthBar(300, 70, 170,20,Lista_Boss[0].vida, 3009, "red", "yellow") if len(Lista_Boss)==1 else None  # Dibuja la barra de habilidad del boss
    habilidad_jugador.draw(screen)  # Dibuja la barra de habilidad en la superficie del juego
    vida_boss.draw(screen) if vida_boss else None  # Dibuja la barra de habilidad del boss si existe
    icono_habilidad= spritesheet_habilidades_prev.get_image(skin_seleccionada, 128,128,0.5,"black")
    texto_boss= font0.render("La maquina de Turing", False, (69, 229, 222)) if len(Lista_Boss) == 1 else None
    screen.blit(texto_boss, (330, 50)) if texto_boss else None
    bombas_img=spritecheet_items.get_image(0,64,64,1.5,"black")
    velocidad_img=spritecheet_items.get_image(1,64,64,1.5,"black")
    escudo_img=spritecheet_items.get_image(2,64,64,1.5,"black")
    cant_bombas =Player_1.items.get("bombas")
    cant_velos=Player_1.items.get("velocidad")
    cant_escus=Player_1.items.get("escudo")
    bombas_tex = font0.render(f" x {cant_bombas}", False, "white")
    velo_text = font0.render(f" x {cant_velos}", False, "white")
    escu_text = font0.render(f" x {cant_escus}", False, "white")
    
    screen.blit(icono_habilidad, (7,30))


    screen.blit(pw_uso_1,(510,20))
    screen.blit(pw_uso_2,(550,0))
    
    screen.blit(bombas_img,(570,0))
    screen.blit (bombas_tex,(598,80))

    screen.blit(velocidad_img,(644,0))
    screen.blit (velo_text,(672,80))

    screen.blit(escudo_img,(718,0))
    screen.blit (escu_text,(746,80))

    screen.blit(texto_tiempo,(327,5))
    screen.blit(texto_puntaje_nivel,(332,25))
    #screen.blit(texto_puntaje_nivel, (425,5))

#________________Auxiliar para pantalla_juego___________
#para el FOV lo pongo aca por mientras
FOV_RADIUS = 100

def is_in_fov_circle(player_pos, obj_pos, radius):
    dx = player_pos[0] - obj_pos[0]
    dy = player_pos[1] - obj_pos[1]
    return dx*dx + dy*dy <= radius * radius

def pantalla_juego() : #ESTRO ES UN PLACEHOLDER PARA LA CLASE DE PANTALLA DE JUEGO  
    global matriz, puntaje_nivel,puntaje_final, estado, llave, candado, powerups, pos_jugador,traps,Lista_Boss
    screen.fill("white")        
    game_surface.fill("black")  # Llama al método mover del jugador 1 para dibujarlo en la pantallag

    dibujar_gui()      
    if primera_vez:
        powerups = generar_powerups(screen, powerups_img, map_cols=11, map_rows=17)
        save_positions(game_surface)
        llave = ubicar_llave(matriz, 48, 48) if nivel<3 or nivel == 4 and len(Lista_Boss)==0 else None #Ubica la llave en una posicion aleatoria de la matriz
       # print(f"llave: {llave.x}, {llave.y}") if llave else print("No hay llave en este nivel")
        candado= llave_candado (100, 100, False , True ,candado_img) if nivel<3 or nivel == 4 and len(Lista_Boss)==0 else None #Ubica el candado en la posicion del candado

    if nivel==4 : 
         if len(Lista_Boss) == 0:
              llave = llave_candado(200,200, True, False ,candado_img) if llave is None else llave #Ubica la llave en una posicion aleatoria de la matriz
              candado= llave_candado (100, 100, False , True ,candado_img) if candado is None else candado #Ubica el candado en la posicion del candado
              
              
     
    pos_jugador = (Player_1.x,Player_1.y)
    if nivel == 1:
          pg.draw.circle(
               game_surface,
               (255, 255, 255),  # color blanco
               (int(Player_1.x)+24, int(Player_1.y+24)),  # posición del jugador
               FOV_RADIUS, 1
               
          )

    generate(game_surface)
    
    bombastic_pos(game_surface)
    bombastic_hitbox()
    
    
    

         
    for trampa in traps:
         trampa.animation()
         if trampa.activo and Player_1.colisiona_con(trampa) and not Player_1.item_en_uso["escudo"]:
              Player_1.vida -= 0.5
    for boss in Lista_Boss:
         if boss.puede_ver_jugador(pos_jugador,obstacles):
              boss.perseguir_jugador(pos_jugador)
         boss.move()
         if boss.habilidad_actual=="El_turing_bus" or boss.habilidad_actual=="El_Bombazo":
              if Player_1.colisiona_con(boss) and not Player_1.item_en_uso["escudo"]:
                   Player_1.vida -= 1
         for bala in boss.lista_balas_enemigas : 
              if Player_1.colisiona_con(bala) and not Player_1.item_en_uso["escudo"]:
                   Player_1.vida -= 0.7

    for ene_3 in Lista_Enemigos_3:
         if ene_3.puede_ver_jugador(pos_jugador,obstacles):
              ene_3.perseguir_jugador(pos_jugador)
         if pos_jugador != None:
               if Enemigos.colisiona_con(ene_3, Player_1):
                    ene_3.animacion_attack(pos_jugador)
         if ene_3.laser is not None:
              if Player_1.colisiona_con(ene_3.laser) and not Player_1.item_en_uso["escudo"]:
                   Player_1.vida -= 0.5
              for obst in obstacles_R:
                   if Enemigos.colisiona_con(ene_3.laser,obst):
                        matriz[int(obst.y/48)][int(obst.x/48)] = 0
                        obstacles_R.remove(obst)
                        obstacles.remove(obst)
         ene_3.move()

    for ene_2 in Lista_Enemigos_2:
         if Player_1.colisiona_con(ene_2) and not Player_1.item_en_uso["escudo"]:
              Player_1.vida-=0.25
         for obst in obstacles:
              if Enemigos.colisiona_con(ene_2,obst):
                   ene_2.rebote()
         if ene_2.puede_ver_jugador(pos_jugador,obstacles):
              ene_2.perseguir_jugador(pos_jugador,obstacles)
         else:
               ene_2.move()

    for ene_1 in Lista_Enemigos_1:
        if Player_1.colisiona_con(ene_1) and not Player_1.item_en_uso["escudo"]:
             Player_1.vida-=0.2
        if nivel != 1:
          ene_1.auto_move()
          #obstaculos funciona con la mascara de los obstaculos, asi pues para hacer colisiones solo ve si hay choque entre mascaras
          for obst in obstacles:
                    if Enemigos.colisiona_con(ene_1, obst):
                                   # aquí ya chocaron
                                   ene_1.rebote()
        else:
             centro = (ene_1.x + 24, ene_1.y + 24)
             ene_1.move_darkness()
             if is_in_fov_circle(pos_jugador,centro,FOV_RADIUS):
                   ene_1.draw()
             for obst in obstacles:
                    centro = (obst.x + 24, obst.y + 24)
                    if Enemigos.colisiona_con(ene_1, obst):
                                   # aquí ya chocaron
                                   ene_1.rebote()
                    if is_in_fov_circle(pos_jugador,centro,FOV_RADIUS):
                         obst.draw()
        
                    
    
    if B_1.bomba_animacion:
         B_1.auto_animate()
    if E_1.bomba_animacion:
         E_1.auto_animate()
         for obsR in obstacles_R:
              puntaje_nivel+=1
              if Explosion.colisiona_con(E_1, obsR):
                   matriz[int(obsR.y/48)][int(obsR.x/48)] = 0
                   obstacles_R.remove(obsR)
                   obstacles.remove(obsR)
                   #print (puntaje_nivel)
         for enemies in Lista_Enemigos_1:
              if Explosion.colisiona_con(E_1, enemies):
                   enemies.animacion_muerte()
         for ene in Lista_Enemigos_2:
              if Explosion.colisiona_con(E_1, ene):
                   ene.vida = ene.vida/2
         for ene_3 in Lista_Enemigos_3:
               if Explosion_Matriz.colisiona_con(E_1,ene_3):
                    ene_3.vida = ene_3.vida/2
     
                   
    Player_1.mover(obstacles)
    Player_1.usar_bomba()
    Player_1.ejecutar_habilidad()

    

     
    screen.blit(game_surface,(0, 100))  # Dibuja la superficie del juego en la pantalla

def pantalla_seleccion_jugador () : 
    global skin_seleccionada, skin_viendo, Player_1, prev_siguiente, prev_seleccion, estado, Player_1, start_time_pantalla, global_fade, Fuerza_exp

    screen.fill("black")


    # Obtener el estado ACTUAL de los botones
    nuevo_viendo_actual = boton_siguiente_opcion.check_click()
    nuevo_seleccion_actual = boton_seleccionar.check_click()
    if nuevo_viendo_actual and not prev_siguiente:  # Solo en el flanco de subida
        skin_viendo += 1
    prev_siguiente = nuevo_viendo_actual  # Actualizar estado previo

    #PREVIEW DE JUGADOR 
    if skin_viendo > 2: 
        skin_viendo %=3
    if skin_viendo == 0:
        Titulo_skin= font1.render ("  Intangible", True, (198, 28, 232)) #texto que muestra el nombre de la skin")
         #dibuja el texto en la pantalla
        desc_skin = font0.render("'Es famoso porque nadie lo ve'", True, (255, 255, 255)) #texto que muestra la descripcion de la skin
        desc_skin2 = font0.render("     Habilidad especial: In-Tangible ", True, (69, 229, 222)) #texto que muestra la descripcion de la skin
        desc_skin3= font0.render("      Este mago conoce las artes oscuras.", True, (129, 133, 137))
        desc_skin4= font0.render("Su habilidad especial es que puede atravesar ", True, (129, 133, 137))
        desc_skin5= font0.render("           Paredes y enemigos con facilidad ", True, (129, 133, 137))
        preview= pg.transform.scale(preview_intangible, (200, 200)) #escala el preview del jugador intangible
        desc_stats= font0.render("Vida maxima : 150           Dano base : 2                 Velocidad : 3", True, (198, 28, 232)) #texto que muestra las estadisticas del jugador
    elif skin_viendo == 1:
        Titulo_skin= font1.render ("   Kamikaze", True, (248, 147, 18)) #texto que muestra el nombre de la skin")
        desc_skin = font0.render("      ' Un alma por una bomba '", True, (255, 255, 255)) #texto que muestra la descripcion de la skin
        desc_skin2 = font0.render("       Habilidad especial: Sacrifice ", True, (202, 28, 28)) #texto que muestra la descripcion de la skin
        desc_skin3= font0.render("Este comerciante conoce sus negocios.", True, (129, 133, 137))
        desc_skin4= font0.render("      Intercambia con los espiritus almas por ", True, (129, 133, 137))
        desc_skin5= font0.render("                       bombas y viceversa.", True, (129, 133, 137))
        preview = pg.transform.scale(preview_kamikaze, (200, 200)) #escala el preview del jugador kamikaze
        desc_stats= font0.render("Vida maxima : 200           Dano base : 1                 Velocidad : 4", True, (248, 147, 18)) #texto que muestra las estadisticas del jugador
    elif skin_viendo == 2:
        Titulo_skin= font1.render ("    Tactico", True, (127,169,7)) #texto que muestra el nombre de la skin")
        desc_skin = font0.render("    '   El hombre que calcula  '", True, (255, 255, 255)) #texto que muestra la descripcion de la skin
        desc_skin2 = font0.render("Habilidad especial: TACTICAL NUKE ", True, (32, 104, 0)) #texto que muestra la descripcion de la skin
        desc_skin3= font0.render("          El famosisimo Beremiz Samir, que ", True, (129, 133, 137))
        desc_skin4= font0.render("tocado por la guerra fue. Su habilidad le permite", True, (129, 133, 137))
        desc_skin5= font0.render("calcular un misil en donde sus enemigos estan ", True, (129, 133, 137))
        preview = pg.transform.scale(preview_tactico, (200, 200))
        desc_stats= font0.render("Vida maxima : 250           Dano base : 3                 Velocidad : 1.5", True, (127,169,7)) #texto que muestra las estadisticas del jugador
    #SELECCION DE JUGADOR 
    if nuevo_seleccion_actual and not prev_seleccion:  # Solo en el flanco de subida
        skin_seleccionada = prev_seleccion
        skin_seleccionada = skin_viendo
        if skin_seleccionada == 0 : 
            Player_1= Jugador_1(game_surface,0,0,4,spritesheet_idle_int,spritesheet_walk_int,spritesheet_habilidad_int,spritesheet_death_int,9,8,8,8,32,32,1.5,"black","Invencible",3,(3, 240, 252),"yellow") #GENERAR PLAYER INVENCIBLE
            Player_1.vida_maxima=150
            Fuerza_exp= 2
        elif skin_seleccionada == 1 : 
            Player_1= Jugador_1(game_surface,0,0,4,spritesheet_idle_kam,spritesheet_walk_kam ,spritesheet_habilidad_kam,spritesheet_death_kam,4,7,12,8,48,32,1.35,"black","Kamikaze",3,(3, 240, 252),"yellow") #GENERAR PLAYER INVENCIBLE
            Player_1.vida_maxima=200
            Fuerza_exp= 1
        elif skin_seleccionada == 2 :
            Player_1= Jugador_1(game_surface,0,0,1.5,spritesheet_idle_tac,spritesheet_walk_tac ,spritesheet_habilidad_tac,spritesheet_death_tac,4,6,9,6,96,96,0.45,"black","Tactico",3,(3, 240, 252),"yellow")   #GENERAR PLAYER TACTICO
            Player_1.vida_maxima = 250
            Fuerza_exp= 3

        estado ="cargar_nivel" #SIEMPRE BAMCIAR EL ESTADO AML SIGUIENTE ANTES DE JUEGO O NO SE 
        start_time_pantalla = pg.time.get_ticks()
        global_fade = False  # Reiniciar el fade global
    prev_seleccion = nuevo_seleccion_actual  # Actualizar estado previo 
 
    screen.blit(Titulo_skin, (300, 50))
    screen.blit(desc_skin, (257, 100))  # Dibuja la descripción de la skin en la pantalla
    screen.blit(desc_skin2, (235, 360))  # Dibuja la descripción de la skin en la pantalla
    screen.blit(desc_skin3, (200, 400))  # Dibuja la descripción de la skin en la pantalla
    screen.blit(desc_skin4, (175, 420))  # Dibuja la descripción de la skin en la pantalla
    screen.blit(desc_skin5, (190, 440))  # Dibuja la descripción de la skin en la pantalla
    screen.blit(preview, (290, 135))  # Dibuja el preview del jugador en la pantalla
    screen.blit(desc_stats, (130, 470))  # Dibuja las estadisticas del jugador en la pantalla

    if not global_fade : 
        fade_in_from_white()
        global_fade = True

    boton_siguiente_opcion.draw(screen)  # Dibuja el botón en la pantalla
    boton_seleccionar.draw(screen)  # Dibuja el botón en la pantalla

def pantalla_creditos() :
     global prev_atras,estado
     bg_men_parallax()
     texto= ["Instituto Tecnologico de Costa Rica","Escuela de Ingieneria en Computacion "," ","2DO PROYECTO IC-1801","Vintage Bomberman Game" ," "," HECHO POR : "," ", "Benjamin Ortiz Quispe ","2025064599"," "," "," "," "," "," ", "Steadman Murillo Parrales", "2025097768"," "," "," "," "," "," "," ","Profesores : "," ", "Jeff Schmidt", "Diego Mora"," "," ","Musica :","Ariabela","ZUN"," ", "Agradecimientos especiales a :"," ","Diego mora", "Jeff Schmidt","Beremiz Samir","Kira"," "," "," ","Creditos de Sprites a sus respectivos autores"," ","Junio 2025"]
     imagenes= [(perro, -90, 1300),(esteman,-50,560),(benja,-50,310)]
     click_atras= boton_back.check_click()
     if click_atras and not prev_atras: 
          star_wars_crawl.offset_y = screen.get_height()
          estado = "menu"
     prev_atras= click_atras
     boton_back.draw(screen)
     star_wars_crawl(screen,texto, imagenes,font,(255,255,255),0.5)

def pantalla_cargar_lvl() : 
     global estado, prev_atras, global_fade, nivel, start_time_pantalla, matriz, lista_B, lista_E, lista_EL, Lista_Enemigos_1, Lista_Enemigos_2, Lista_Enemigos_3, obstacles, obstacles_R, primera_vez, hielo, traps,Fuerza_exp

     if not global_fade : 
          fade_in_from_white()
          global_fade = True
     screen.fill("black")
     titulo= font_tit.render(F"NIVEL {nivel+1}", True, (255, 255, 255))
     screen.blit(titulo, (285, 230))
     matriz=[]
     Lista_Enemigos_1=[]
     Lista_Enemigos_2=[]
     Lista_Enemigos_3=[] 
     lista_B = []
     lista_E = []
     lista_EL = []
     obstacles = []
     obstacles_R = []
     hielo = []
     traps=[]
     Player_1.x=0
     Player_1.y=0
     Player_1.vida= Player_1.vida_max_actual
     Player_1.tiene_llave = False


     primera_vez=True
     tiempo_juego.tiempo=300

def pantalla_g_o () : 
     global estado, puntaje_final, prev_atras, global_fade, nivel, powerups, primera_vez, matriz
     global Lista_Enemigos_1 , Lista_Enemigos_2, Lista_Enemigos_3, obstacles, obstacles_R, lista_B , lista_E , lista_EL, lista_B_Boss, lista_E_Boss, lista_EL_Boss, Lista_Boss, hielo
     if not global_fade : 
          fade_in_from_white()
          global_fade = True
     screen.fill("black")
     titulo= font_tit1.render("GAME OVER", True, (237, 22, 22))
     screen.blit(titulo, (screen.get_width() // 2 - titulo.get_width() // 2, 100))
     texto_puntaje = font0.render(f"Puntaje final: {puntaje_final}", True, (255, 255, 255))
     screen.blit(texto_puntaje, (screen.get_width() // 2 - texto_puntaje.get_width() // 2, 200))
     click_atras = boton_back.check_click()
     boton_back.draw(screen)
     if click_atras and not prev_atras:
          global_fade = False
          powerups = None
          primera_vez= False
          matriz=[]
          Lista_Enemigos_1=[]
          Lista_Enemigos_2=[]
          Lista_Enemigos_3=[] 
          lista_B = []
          lista_E = []
          lista_EL = []
          obstacles = []
          obstacles_R = []
          Lista_Boss=[]
          lista_B_Boss = []
          lista_E_Boss = []
          lista_EL_Boss = []
          hielo = []
          Player_1.tiene_llave = False
          Player_1.puntos_compra = 0
          Player_1.cant_vidas = 3

          estado = "guardar_puntaje"
     prev_atras = click_atras

def pantalla_compra_powerups() : 
     global  global_fade, estado, prev_atras, estado_anterior, prev_comprar_vidas, prev_comprar_dano, prev_comprar_pts, puntaje_final, Fuerza_exp, prev_siguiente_nivel, start_time_pantalla, lista_pw_uso
     if not global_fade :     
          fade_in_from_white()
          global_fade = True
     screen.blit(fondo_compra,(0,0))
     titulo= font_tit1.render("COMPRA DE POWERUPS", True, (255, 255, 255))
     screen.blit(titulo, (screen.get_width() // 2 - titulo.get_width() // 2, 50))

     texto_puntaje = font0.render(f"Puntaje actual: {puntaje_final}", True, (113, 113, 150))
     screen.blit(texto_puntaje, (screen.get_width() // 2 - texto_puntaje.get_width() // 2, 100))

     texto_puntos_pw= font0.render(f"Puntos disponibles para comprar powerups: {Player_1.puntos_compra}", True, (113, 113, 150))
     screen.blit(texto_puntos_pw, (screen.get_width() // 2 - texto_puntos_pw.get_width() // 2, 125))

     texto_vida= font0.render(f"Vida maxima actual : {Player_1.vida_max_actual}/ {Player_1.vida_maxima}", True, (252, 118, 109))
     screen.blit(texto_vida, (screen.get_width() // 2 - texto_vida.get_width() // 2, 160))     

     texto_dano= font0.render(f"Dano actual : {Fuerza_exp}", True, (196, 116, 4))
     screen.blit(texto_dano, (screen.get_width() // 2 - texto_dano.get_width() // 2, 230))

     vida_max_actual_healtbbar= HealthBar(310, 190, 200, 20, Player_1.vida_max_actual, Player_1.vida_maxima, (129, 133, 137), "red")  # Dibuja la barra de salud del jugador
     vida_max_actual_healtbbar.draw(screen)  # Dibuja la barra de salud en la superficie del jueg

     dano_maximo_actual= HealthBar(310, 260, 200, 20, Fuerza_exp, 6, (129, 133, 137), "orange")  # Dibuja la barra de salud del jugador
     dano_maximo_actual.draw(screen)  # Dibuja la barra de salud en la superficie del juego

     boton_comprar_dano.draw(screen)  # Dibuja el botón en la pantalla
     boton_comprar_vidas.draw(screen)  # Dibuja el botón en la pantalla
     boton_comprar_pts.draw(screen)  # Dibuja el botón en la pantalla
     boton_continuar_nivel.draw(screen)  # Dibuja el botón en la pantalla

     if prev_comprar_pts and not boton_comprar_pts.check_click():
          if puntaje_final >= 500:
               Player_1.puntos_compra += 1
               puntaje_final -= 500
     prev_comprar_pts = boton_comprar_pts.check_click()

     if prev_comprar_vidas and not boton_comprar_vidas.check_click():
          if Player_1.puntos_compra >= 2:
               Player_1.vida_max_actual += 25
               Player_1.puntos_compra -= 2
               lista_pw_uso.append("vida") if not "vida" in lista_pw_uso else None  # Agrega el powerup de vida a la lista de powerups usados
     prev_comprar_vidas = boton_comprar_vidas.check_click()

     if prev_comprar_dano and not boton_comprar_dano.check_click():
          if Player_1.puntos_compra >= 3:
               Fuerza_exp += 1
               Player_1.puntos_compra -= 3
               lista_pw_uso.append("dano") if not "dano" in lista_pw_uso else None
     prev_comprar_dano = boton_comprar_dano.check_click()

     if prev_siguiente_nivel and not boton_continuar_nivel.check_click():
          estado= "cargar_nivel"
          start_time_pantalla = pg.time.get_ticks()
     prev_siguiente_nivel = boton_continuar_nivel.check_click()


     return

def pantalla_win() : 
     bg_men_parallax()
     global estado, nivel, start_time_pantalla, global_fade, primera_vez, puntaje_final, estado, anterior_puntaje_guardar, global_cuadrado
     if not global_fade :
          fade_in_from_white()
          global_fade = True
     texto_good_ending= font_tit.render("GOOD ENDING", True, (255,255,255))
     screen.blit(texto_good_ending, (screen.get_width() // 2 - texto_good_ending.get_width() // 2, 30))
     texto_puntaje = font.render(f"Puntaje final: {puntaje_final}", True, "green")
     screen.blit(texto_puntaje, (screen.get_width() // 2 - texto_puntaje.get_width() // 2, 100))
     texto_final = font0.render("Felicidades, Has completado el juego.", True, (255, 255, 255))
     screen.blit(texto_final, (screen.get_width() // 2 - texto_final.get_width() // 2, 300))
     texto_final2 = font0.render("Gracias por jugar.", True, (255, 255, 255))
     screen.blit(texto_final2, (screen.get_width() // 2 - texto_final2.get_width() // 2, 350))
     texto_final3 = font0.render("Steadman Murillo, Benjamin Ortiz  2025", True, (255, 255, 255))
     screen.blit(texto_final3, (screen.get_width() // 2 - texto_final3.get_width() // 2, 400))

     if not anterior_puntaje_guardar and boton_guardar_puntaje.check_click():
          estado = "guardar_puntaje"
          global_cuadrado = False  # Reiniciar el estado del cuadrado
     anterior_puntaje_guardar = boton_guardar_puntaje.check_click()

     boton_guardar_puntaje.draw(screen)  # Dibuja el botón en la pantalla

def pantalla_guardar_partida() : 
     global global_cuadrado, bara_texto, anterior_puntaje_guardar, estado, puntaje_final, nivel, Player_1, estado_anterior
     bg_men_parallax()
     if not global_cuadrado :
          animar_cuadro(screen)
     
     rectangulo_entrada= pg.Rect (340, 460, 135, 30)    
     pg.draw.rect(screen, "white", rectangulo_entrada, 0, 4)  
     pg.draw.rect(screen, "black", rectangulo_entrada, 2, 4)  
     texto_entrada = font.render(bara_texto, False, "black")
     screen.blit(texto_entrada, (rectangulo_entrada.x + 5, rectangulo_entrada.y + 5))
     texto_ingrese_Tu_nombre = font0.render("Ingrese su nombre:", False, "white")
     screen.blit(texto_ingrese_Tu_nombre, (rectangulo_entrada.x -25, rectangulo_entrada.y +30))

     titulo= font_tit1.render("PARTIDAS ", False, "white")
     screen.blit(titulo,(320,70))
     data=cargar_partidas()
     todas= data.get("partidas",[])
     mejores= sorted(todas, key=lambda p: p["puntaje"],reverse=True)
     max_display = min(len(mejores), 7)    #solo top5
     top_cinco = mejores[:max_display]
     dibujar_scoreboard(screen , top_cinco, font, x=100, y=150, line_height=40 )

     puntaje_final_txt = font0.render(f"Puntaje final: {puntaje_final}", False, "green")

     personaje_actual_txt= font0.render(f"Personaje : {Player_1.habilidad}", False, "green")

     nivel_actual_txt = font0.render(f"Nivel actual: {nivel}", False, "green")
     screen.blit(puntaje_final_txt, (100, 120))
     screen.blit(personaje_actual_txt, (280, 120))
     screen.blit(nivel_actual_txt, (530, 120))

     boton_scoreboard_puntaje.draw(screen)  # Dibuja el botón en la pantalla
     if boton_scoreboard_puntaje.check_click() and not anterior_puntaje_guardar:
          nueva_partida(bara_texto, puntaje_final, Player_1.habilidad,nivel)  # Guarda la partida con el nombre ingresado
          puntaje_final = 0  # Reinicia el puntaje final después de guardar
          global_cuadrado = False  # Reiniciar el estado del cuadrado
          bara_texto = ""  # Reinicia
          Player_1=None
          nivel= 0
          estado="menu"

     anterior_puntaje_guardar = boton_scoreboard_puntaje.check_click()

def boombox() :
     global estado_anterior
     if estado!= estado_anterior : 
          if (estado == 'menu' or estado == 'opciones') and (estado_anterior == 'menu' or estado_anterior == 'opciones'):
               pass  # No se detiene ni se reinicia la música
          elif (estado == 'good_ending' or estado == 'guardar_puntaje') and (estado_anterior == 'good_ending' or estado_anterior == 'guardar_puntaje'):
               pass  # No se detiene ni se reinicia la música
          else : 
            pg.mixer.music.stop()
            if estado == 'menu':
                pg.mixer.music.load("sounds/music/Main_menu.mp3")
            elif estado == "puntajes":
                pg.mixer.music.load("sounds/music/puntajes.mp3")
            elif estado == "creditos":
                pg.mixer.music.load("sounds/music/credits.mp3")
            elif estado == "cargar_nivel":
                pg.mixer.music.load("sounds/sfx/cambio_lvl.mp3")
            elif estado == "seleccion_personaje":
                pg.mixer.music.load("sounds/music/player_selection.mp3")
            elif estado == "comprar_powerups":
                pg.mixer.music.load("sounds/music/compra.mp3")
            elif estado == "good_ending":
                pg.mixer.music.load("sounds/music/good_ending.mp3")
            elif estado == "guardar_puntaje":
                pg.mixer.music.load("sounds/music/name_selection.mp3")
            else:
                return  # ningún cambio de música

            pg.mixer.music.set_volume(volumen)
            pg.mixer.music.play(-1)
     estado_anterior = estado

tiempo_juego.start()

while True:
#cambiador de estado
    boombox()
    tiempo_Actual = pg.time.get_ticks()
    if estado == "juego":  # Si el estado es "juego", se muestra la pantalla de juego
        tiempo_juego.reanudar()
        pantalla_juego()
        primera_vez = False

    elif estado == "seleccion_personaje":  # Si el estado es "creacion_niveles", se muestra la pantalla de creación de niveles
        pantalla_seleccion_jugador()
    elif estado=="menu" : 
        pantalla_titulo()
    elif estado=="opciones" : 
         pantalla_opciones()
    elif estado== "puntajes" : 
         pantalla_puntajes()
    elif estado=="creditos" : 
         pantalla_creditos()   
    elif estado == "GameOver":     
        pantalla_g_o()
    elif estado == "comprar_powerups":
        pantalla_compra_powerups()
    elif estado == "good_ending":
        pantalla_win() 
    elif estado == "guardar_puntaje":
         pantalla_guardar_partida()
    elif estado == "cargar_nivel":
         pantalla_cargar_lvl()
         if tiempo_Actual - start_time_pantalla > 1900:
             nivel += 1
             init(nivel)
             Player_1.x=0
             Player_1.y=0
             puntaje_final += puntaje_nivel
             puntaje_nivel = 0
             primera_vez = True
             tiempo_juego.tiempo=300
             tiempo_juego.reanudar()  # Reinicia el temporizador para el nuevo nivel
             estado = "juego"
     
    for event in pg.event.get():
        if event.type == pg.QUIT:
            tiempo_juego.detener()
            pg.quit()
            sys.exit()
        elif event.type == pg.KEYDOWN : 
              if estado == "juego":
                    if event.key == pg.K_ESCAPE:
                         puntaje_final += puntaje_nivel
                         puntaje_nivel = 0
                         estado = "GameOver"

              elif estado== "guardar_puntaje" : 
                    if event.key == pg.K_BACKSPACE:
                         bara_texto = bara_texto[:-1]
                    else:
                         bara_texto += event.unicode if len(bara_texto) < 10 else ""   
        elif event.type == pg.MOUSEBUTTONDOWN:
               mouse_pos = pg.mouse.get_pos()
               if estado == "juego":
                    if Player_1.ejecutando_habilidad:
                         if Player_1.habilidad=="Tactico" : 
                              if 0 < mouse_pos[0] < 816 and 100 < mouse_pos[1] < 628:
                                   B_1 = Bomba(game_surface, mouse_pos[0]-32, mouse_pos[1]-132, spritesheet_Bomba, 5, 64, 64, 0.75, 'black',True)
                                   E_1 = Explosion(game_surface, mouse_pos[0]-88, mouse_pos[1]-200, spritesheet_exp_c, 4, 64, 64, 3, 'black',False)    
    pg.display.flip()
    reloj.tick(60)

#TODO : benja
#*!DOCUMENTACION 

#TODO : steadman




