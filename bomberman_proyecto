#                   PROYECTO DE BOMBERMAN 
#                  BENJAMIN ORTIZ 2025064599
#                  STEADMAN MURILLO 2025097768
#           IC-1802 INTRODUCCION A LA PROGRAMACION 
#                     I SEMESTRE DE 2025


import pygame as pg
import time as t
import random 
import sys 
import os 

#Aqui epiezan las clases del juego  
#----------------------------------------------------------CLASES UTILES DE PYGAME---------------------------------------

# Clase SpriteSheet: Carga una hoja de sprites y permite obtener imágenes individuales.
class SpriteSheet (): 
    def __init__(self, image): 
        self.sheet = image  # Carga la imagen de la hoja de sprites
    
    def get_image(self, frame, width, height, scale, colour):
        image = pg.Surface((width, height)).convert_alpha()     # Crea una superficie para el frame
        image.blit(self.sheet, (0, 0), ((frame * width), 0, width, height))  # Copia el frame correspondiente de la hoja de sprites
        image = pg.transform.scale(image, (width * scale, height * scale))  # Escala la imagen al tamaño deseado
        image.set_colorkey(colour)      # Establece el color clave para hacer transparente el fondo

        return image
#CLASE BOTON: Representa un botón en la interfaz del juego.
class Boton : 
    def __init__(self, x, y, width, height, text, font,size, color, hover_color ):    # '"ALERTA  : EN FONT TIENE QUE RECIBIR LA STRING DE LA DIRECCION DE LA FUENTE, POR EJEMPLO "fonts/arial.ttf"'
        self.rect = pg.Rect(x, y, width, height)  # Crea un rectángulo para el botón
        self.text = text  # Texto del botón
        self.font = pg.font.Font(font,size)  # Fuente del texto
        self.color = color 
        self.size = size # Color normal del botón
        self.hover_color = hover_color  # Color al pasar el mouse sobre el botón
        self.last_mouse_state  = None   # Tipo de acción (por ejemplo, cambiar de estado)
    def check_click(self):
        mouse_pos = pg.mouse.get_pos()
        mouse_pressed = pg.mouse.get_pressed()[0]
        # Detectar solo el momento exacto cuando se presiona el botón  
        if self.rect.collidepoint(mouse_pos):
            if mouse_pressed and not self.last_mouse_state:  # Solo en el frame del clic inicial
                return True  # Retorna True si el botón fue presionado
            return False
        return False

    def draw(self, surface):
        mouse_pos = pg.mouse.get_pos()  # Obtiene la posición del mouse
        if self.rect.collidepoint(mouse_pos):  # Verifica si el mouse está sobre el botón
            pg.draw.rect(surface, self.hover_color, self.rect,int(self.size*0.55),int(self.size*0.2))  # Dibuja el botón con el color de hover
        else:
            pg.draw.rect(surface, self.color, self.rect,int(self.size*0.55),int(self.size*0.2))  # Dibuja el botón con el color normal
          # Establece el tamaño de la fuente
        text_surface = self.font.render(self.text, True, (255, 255, 255))  # Renderiza el texto del botón
        text_rect = text_surface.get_rect(center=self.rect.center)  # Centra el texto en el botón
        surface.blit(text_surface, text_rect)  # Dibuja el texto en la superficie

class HealthBar:
    def __init__(self, x, y, width, height, hp,color_f,color_h):
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.hp = hp  # Salud actual del jugador
        self.color_f = color_f
        self.color_h = color_h  # Color de la barra de salud    
    def draw(self, surface):
        ratio= self.hp / 100 # Calcula la proporción de salud actual respecto a la máxima
        pg.draw.rect(surface, self.color_f, (self.x, self.y, self.width, self.height))  # Dibuja el fondo de la barra de salud   
        pg.draw.rect(surface, self.color_h, (self.x, self.y, self.width * ratio, self.height))

class Healthbar_Player (HealthBar) :
    def __init__(self, x, y, width, height, hp, heart_texture, cant_vidas, font):
        super().__init__(x, y, width, height, hp, (255, 0, 0), (0, 255, 0))  # Llama al constructor de HealthBar con colores por defecto
        self.heart_texture = heart_texture  # Textura del corazón para la barra de salud
        self.cant_vidas = cant_vidas  # Cantidad de vidas del jugador
        self.font = font  # Fuente para mostrar la cantidad de vidas
    def draw_atributes(self, surface):
        surface.blit(self.heart_texture, (self.x - heart_texture.get_width()-3, self.y-5))  # Dibuja el corazón en la barra de salud
        vidas=self.font.render (f"x {self.cant_vidas}", True, (255, 255, 255)) # Renderiza la cantidad de vidas del jugador
        surface.blit(vidas, (self.x - heart_texture.get_width()-32, self.y+5))  # Dibuja la cantidad de vidas en la barra de salud


# -------------------------------------------------------CLASES DEL JUEGO-------------------------------------------
# Clase Jugador: Representa al jugador en el juego.

class Jugador : 
    def __init__(self, area_juego, pos_x, pos_y, velocidad, spritesheet_idle,spritesheet_habilidad, frame_count, frame_w,frame_h, scale, colour): 
        self.area_juego = area_juego #superficie del juego donde se dibuja el jugador
        self.x = pos_x
        self.y = pos_y
        self.velocidad = velocidad              #velocidad del jugador
        self.spritesheet_idle = spritesheet_idle
        self.spritesheet_habilidad = spritesheet_habilidad
        self.current_spritesheet = spritesheet_idle  # Por defecto usamos idle        #LA SPRITESHEET DEL JUGADOR
        self.frame_count = frame_count          #CAANTIDAD DE FRAMES DE LA SKIN DEL JUGAODR
        self.width_frame = frame_w
        self.height_frame = frame_h   #esto siempre es estatico. como las spritesheets son horizontales entonces esto que qeuda asi . 
        self.scale = scale                              #multiplicador de escala para el sprite
        self.colour = colour                  #color de fondo del sprite que se va a eliminar
        self.last_update = t.time()     #tiempo de la ultima actualizacion del frame
        self.current_frame = 0        #numero de frame que esta actualmente dibujandose.
        self.current_skin = self.current_spritesheet.get_image(0, 30, 30, scale, colour)
        self.mask= pg.mask.from_surface(self.current_skin)  # Crea una máscara del sprite actual para colisiones
    
    def cambiar_spritesheet(self, nuevo_spritesheet): #esto es para cambiar la spritesheet del jugador, por ejemplo cuando se ejecuta una habilidad
        self.current_spritesheet = nuevo_spritesheet #cambia el spritesheet actual al nuevo
        self.current_frame = 0  #reinicia el frame actual a 0
        self.last_update = t.time()     #reinicia el tiempo de la ultima actualizacion para que no se salte frames al cambiar de spritesheet
    
    def animacion_skin(self) : 
        current_time = t.time()
        if current_time - self.last_update > 0.1 : # Cambio de frame cada 0.2 segundos
            self.last_update = current_time
            self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
        self.current_skin = self.current_spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)
        self.mask = pg.mask.from_surface(self.current_skin)
        

    def colisiona_con(self, otro_objeto):
        # Calcular diferencia de posiciones (offset)
        offset_x = int(otro_objeto.x) - int(self.x)
        offset_y = int(otro_objeto.y) - int(self.y)
        return self.mask.overlap(otro_objeto.mask, (offset_x, offset_y)) is not None
    
    def mover(self): #metodo para mover al jugador, recibe el frame actual y la velocidad: 
        #metodo para mover al jugador, recibe el frame actual
        self.animacion_skin()
        largo = self.area_juego.get_width() #ancho del aarea de juego
        alto = self.area_juego.get_height()   #alto del area de juego

        ancho_frame = int(self.width_frame * self.scale)    #ancho real del frame del jugador
        alto_frame = int(self.height_frame * self.scale)    #alto real del frame del jugador

        keys = pg.key.get_pressed() #mover el pene
        if keys[pg.K_LEFT] and self.x > 0:  #verifica que el jugador no se salga del frame
            self.x -= self.velocidad #mueve al jugador a la izquierda
        if keys[pg.K_RIGHT] and self.x + ancho_frame < largo:
            self.x += self.velocidad    #mueve al jugador a la derecha
        if keys[pg.K_UP] and self.y > 0:
            self.y -= self.velocidad  #mueve al jugador hacia arriba
        if keys[pg.K_DOWN] and self.y +  alto_frame < alto:
            self.y += self.velocidad  #mueve al jugador hacia abajo
        #actualiza la posicion del jugador en el frame  
        self.area_juego.blit(self.current_skin, (self.x, self.y))
class Jugador_1(Jugador): #clase hija de jugador, que hereda de la clase padre
    def __init__(self, area_juego, pos_x, pos_y, spritesheet_idle,spritesheet_hab,frame_count,F_w,f_H,scale,colour,habilidad, cant_vidas,color_habilidad, color_bajada ):
        super().__init__( area_juego, pos_x, pos_y, 5, spritesheet_idle,spritesheet_hab, frame_count,F_w,f_H, scale, colour)
        self.habilidad=habilidad
        self.vida=97 #vida del jugador
        self.ejecutando_habilidad = False
        self.tiempo_inicio_habilidad = 0
        self.max_tiempo_habilidad = 5  # 5 segundos máximo
        self.cant_vidas = cant_vidas  # Cantidad de vidas del jugador
        self.color_habilidad = color_habilidad  # Color de la habilidad
        self.color_subiendo =color_habilidad
        self.barra_habilidad = 0  # Tiempo de recarga de la habilidad
        self.color_bajada=color_bajada
    def ejecutar_habilidad(self ) :
        keys = pg.key.get_pressed()
        current_time = t.time()
        # Iniciar habilidad al presionar espacio
        if keys[pg.K_SPACE] and not self.ejecutando_habilidad and self.barra_habilidad >50:
            self.ejecutando_habilidad = True
            self.tiempo_inicio_habilidad = current_time
            self.cambiar_spritesheet(self.spritesheet_habilidad)
            print(f"Iniciando habilidad: {self.habilidad}")
        
        # Detener si pasa el tiempo máximo
        if self.ejecutando_habilidad:
            tiempo_transcurrido = current_time - self.tiempo_inicio_habilidad
            self.barra_habilidad -=1 if self.barra_habilidad >= 1 else self.barra_habilidad==1
            self.color_habilidad = self.color_bajada
            
            if tiempo_transcurrido > self.max_tiempo_habilidad or int(self.barra_habilidad)==0:
                self.ejecutando_habilidad = False
                self.cambiar_spritesheet(self.spritesheet_idle)
                print("Habilidad detenida por tiempo máximo")
        
        # Detener al soltar la tecla
        '''if not keys[pg.K_SPACE] and self.ejecutando_habilidad:
            self.ejecutando_habilidad = False
            self.cambiar_spritesheet(self.spritesheet_idle)
            print("Habilidad detenida al soltar espacio")'''

        if not self.ejecutando_habilidad:
            self.color_habilidad=self.color_subiendo
            self.barra_habilidad = min(self.barra_habilidad + 0.1, 100)   #ni idea porque co 99 sirve pero con ese numero me deja la barra en 100 maximo xd  


#ocupo tipo scar tiempo. si en 0,5s no se presiona ninguna tecla entonces el sprote es el statico, si en n se presiona deacruerdo al movimiento cambia el sprite. sis e presiona el de habiliad, entones se muestra el speiret habilidad.

#-----------------------pygame------------------------------

#commons de pygame (literalmente el inicio de pygame)
pg.init()
screen= pg.display.set_mode((816, 624)) #tamano de pantalla
pg.display.set_caption("El hombre que tiraba bombas") #Nombre de la ventana
reloj = pg.time.Clock() #reloj comun para controlar FPS

#-----------------------GLOBALES------------------------------
estado = "juego" #se inicializa el estado del juego como "start", que representa el menu de inicio (ahorita esta en seleccion de pers por unas pruebas q taba haciendo)
#-----------------------SPRITES------------------------------

#-------------area de juego-----------
game_surface = pg.Surface((816,524)) #*! ya cambie el tamano del frame enves de 624 a 524, estaba pintando el frame 100 pix hacia abajo y hacia que pete todo

#------------------------TEXTURAS------------------------------
heart_texture = pg.image.load("assets/textures/heart.png").convert_alpha() #carga la textura del corazon
#------------------------SPRITES DE JUGADORES------------------------------

#--- Intangible ----
imp_sps_intangible= pg.image.load("assets\sprites\players\Intangible\idle.png").convert_alpha() #placeholder para el sprite intangible
imp_sps_intalgible_hab= pg.image.load("assets\sprites\players\Intangible\invisible.png").convert_alpha() #placeholder para el sprite intangible de habilidad
imp_sps_intangible_run= pg.image.load("assets\sprites\players\Intangible\correr.png").convert_alpha() #placeholder para el sprite intangible de correr

preview_intangible = pg.image.load("assets\sprites\players\Intangible\preview.png").convert_alpha() 
preview_tactico = pg.image.load("assets\sprites\players\Tactico\preview.png").convert_alpha() 
preview_kamikaze = pg.image.load("assets\sprites\players\Kamikaze\preview.png").convert_alpha() 
#-----------------------SPRITESHEET DE JUGADORES ------------------------------

#instancia del jugador 1    
spritesheet_idle_int= SpriteSheet(imp_sps_intangible) #crea una instancia de la clase SpriteSheet con el sprite del jugador
spritesheet_habilidad_int= SpriteSheet(imp_sps_intalgible_hab) #crea una instancia de la clase SpriteSheet con el sprite de habilidad del jugador
sritesheet_run_int = SpriteSheet(imp_sps_intangible_run) #crea una instancia de la clase SpriteSheet con el sprite de correr del jugador

Player_1 = Jugador_1(game_surface, 100, 100,spritesheet_idle_int,spritesheet_habilidad_int,9,32,32,1.5,"black", "Invisibilidad",3,(69, 229, 222), "yellow" ) #placeholder de player1
#VARIABLES GLOBALES 
font = pg.font.Font("fonts/Pixeltype.ttf", 20) #fuente para mostrar info de cada skin del player
font0= pg.font.Font("fonts/Pixeltype.ttf", 30) #fuente para mostrar info de cada skin del player
font1= pg.font.Font("fonts/Pixeltype.ttf", 50) #fuente para mostrar titulo de cada skin de player   
skin_seleccionada = 0                   #variable global para controlar la skin que selecciona en la aprte de seleccion de jugador (skin)
skin_viendo=0



##BOTONES GLOBALES 
boton_siguiente_opcion= Boton(300, 500, 150, 30, "Siguiente", "fonts/Pixeltype.ttf", 28, (44, 62, 80), (52, 73, 94 )) #"crea un boton de siguiente opcion (tiene que estar afuera por tipo int)
boton_seleccionar = Boton(300, 540, 150, 30, "Seleccionar", "fonts/Pixeltype.ttf", 28, (44, 62, 80), (52, 73, 94 ) ) #crea un boton de seleccionar

prev_siguiente = False #variable para controlar si se ha hecho clic en el botón de siguiente opción
prev_seleccion = False  #variable para controlar si se ha hecho clic en el botón de seleccionar

#estados de juego :
def pantalla_juego() : #ESTRO ES UN PLACEHOLDER PARA LA PANTALLA DE juego
    screen.fill((24,24,24))
    game_surface.fill("black")  # Llama al método mover del jugador 1 para dibujarlo en la pantalla
    Player_1.mover()
    Player_1.ejecutar_habilidad() 
    vida_jugador=Healthbar_Player (73, 15, 110, 20, Player_1.vida, heart_texture,Player_1.cant_vidas,font0)  # Dibuja la barra de salud del jugador
    vida_jugador.draw(screen)  # Dibuja la barra de salud en la superficie del juego
    vida_jugador.draw_atributes(screen)  # Dibuja los atributos de la barra de salud en la superficie del juego

    habilidad_jugador= HealthBar(73, 45, 110, 20, Player_1.barra_habilidad, (129, 133, 137), Player_1.color_habilidad)  # Dibuja la barra de habilidad del jugador
    habilidad_jugador.draw(screen)  # Dibuja la barra de habilidad en la superficie del juego
    screen.blit(game_surface,(0, 100))  # Dibuja la superficie del juego en la pantalla



def pantalla_seleccion_jugador () : 
    global skin_seleccionada, skin_viendo, Player_1, prev_siguiente, prev_seleccion
    screen.fill("black")
    # Obtener el estado ACTUAL de los botones
    nuevo_viendo_actual = boton_siguiente_opcion.check_click()
    nuevo_seleccion_actual = boton_seleccionar.check_click()
    if nuevo_viendo_actual and not prev_siguiente:  # Solo en el flanco de subida
        skin_viendo += 1
    prev_siguiente = nuevo_viendo_actual  # Actualizar estado previo
    if nuevo_seleccion_actual and not prev_seleccion:  # Solo en el flanco de subida
        skin_seleccionada += 1
    prev_seleccion = nuevo_seleccion_actual  # Actualizar estado previo


    if skin_viendo > 2: 
        skin_viendo %=3
    if skin_viendo == 0:
        Titulo_skin= font1.render ("  Intangible", True, (198, 28, 232)) #texto que muestra el nombre de la skin")
         #dibuja el texto en la pantalla
        desc_skin = font0.render("'Es famoso porque nadie lo ve'", True, (255, 255, 255)) #texto que muestra la descripcion de la skin
        desc_skin2 = font0.render("     Habilidad especial: In-Tangible ", True, (69, 229, 222)) #texto que muestra la descripcion de la skin
        desc_skin3= font0.render("      Este mago conoce las artes oscuras.", True, (129, 133, 137))
        desc_skin4= font0.render("Su habilidad especial es que puede atravesar ", True, (129, 133, 137))
        desc_skin5= font0.render("           Paredes y enemigos con facilidad ", True, (129, 133, 137))
        preview= pg.transform.scale(preview_intangible, (200, 200)) #escala el preview del jugador intangible
    elif skin_viendo == 1:
        Titulo_skin= font1.render ("   Kamikaze", True, (248, 147, 18)) #texto que muestra el nombre de la skin")
        desc_skin = font0.render("      ' Un alma por una bomba '", True, (255, 255, 255)) #texto que muestra la descripcion de la skin
        desc_skin2 = font0.render("       Habilidad especial: Sacrifice ", True, (202, 28, 28)) #texto que muestra la descripcion de la skin
        desc_skin3= font0.render("Este comerciante conoce sus negocios.", True, (129, 133, 137))
        desc_skin4= font0.render("      Intercambia con los espiritus almas por ", True, (129, 133, 137))
        desc_skin5= font0.render("                       bombas y viceversa.", True, (129, 133, 137))
        preview = pg.transform.scale(preview_kamikaze, (200, 200)) #escala el preview del jugador kamikaze
    elif skin_viendo == 2:
        Titulo_skin= font1.render ("    Tactico", True, (127,169,7)) #texto que muestra el nombre de la skin")
        desc_skin = font0.render("    '   El hombre que calcula  '", True, (255, 255, 255)) #texto que muestra la descripcion de la skin
        desc_skin2 = font0.render("Habilidad especial: TACTICAL NUKE ", True, (32, 104, 0)) #texto que muestra la descripcion de la skin
        desc_skin3= font0.render("          El famosisimo Beremiz Samir, que ", True, (129, 133, 137))
        desc_skin4= font0.render("tocado por la guerra fue. Su habilidad le permite", True, (129, 133, 137))
        desc_skin5= font0.render("calcular un misil en donde sus enemigos estan ", True, (129, 133, 137))
        preview = pg.transform.scale(preview_tactico, (200, 200))

    if skin_seleccionada == 0 : 
        Player_1 = Jugador_1(game_surface, 100, 100,spritesheet_idle_int,spritesheet_habilidad_int,9,32,32,2,"black", "Invisibilidad")
    elif skin_seleccionada == 1 :
        None
 
    screen.blit(Titulo_skin, (300, 50))
    screen.blit(desc_skin, (257, 100))  # Dibuja la descripción de la skin en la pantalla
    screen.blit(desc_skin2, (235, 360))  # Dibuja la descripción de la skin en la pantalla
    screen.blit(desc_skin3, (200, 400))  # Dibuja la descripción de la skin en la pantalla
    screen.blit(desc_skin4, (175, 420))  # Dibuja la descripción de la skin en la pantalla
    screen.blit(desc_skin5, (190, 440))  # Dibuja la descripción de la skin en la pantalla
    screen.blit(preview, (290, 135))  # Dibuja el preview del jugador en la pantalla




    boton_siguiente_opcion.draw(screen)  # Dibuja el botón en la pantalla
    boton_seleccionar.draw(screen)  # Dibuja el botón en la pantalla

while True:
#cambiador de estado
    if estado == "juego":  # Si el estado es "juego", se muestra la pantalla de juego
        pantalla_juego()
    elif estado == "seleccion_personaje":  # Si el estado es "creacion_niveles", se muestra la pantalla de creación de niveles
        pantalla_seleccion_jugador()
    else:  # Si el estado no es reconocido, se muestra un mensaje de error
        print("Estado no reconocido")
    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()
            sys.exit()  

    pg.display.flip()
    reloj.tick(45)


#TODO : 
# - Agregar mas jugadores
# - Agregar mas habilidades
# - Agregar mas estados de juego
# - Agregar mas pantallas de juego
# - Agregar mas botones
# - Agregar mas sprites 
# - Agregar mas sonidos
# - Agregar mas musica
# - Agregar mas niveles
# - Agregar mas enemigos
# - Agregar mas power ups
# - Agregar mas bombas
# - Agregar mas explosiones
# - Agregar mas efectos
# - Agregar mas animaciones
# - Agregar mas menus
# - Agregar mas opciones
# - Agregar mas configuraciones
