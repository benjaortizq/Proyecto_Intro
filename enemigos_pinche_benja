import pygame as pg
import time as t
import random 
import sys 
import os 

#Aqui epiezan las clases del juego  
#----------------------------------------------------------CLASES UTILES DE PYGAME---------------------------------------

# Clase SpriteSheet: Carga una hoja de sprites y permite obtener imágenes individuales.
class SpriteSheet (): 
    def __init__(self, image): 
        self.sheet = image  # Carga la imagen de la hoja de sprites
    
    def get_image(self, frame, width, height, scale, colour):
        image = pg.Surface((width, height)).convert_alpha()     # Crea una superficie para el frame
        image.blit(self.sheet, (0, 0), ((frame * width), 0, width, height))  # Copia el frame correspondiente de la hoja de sprites
        image = pg.transform.scale(image, (width * scale, height * scale))  # Escala la imagen al tamaño deseado
        image.set_colorkey(colour)      # Establece el color clave para hacer transparente el fondo

        return image
    
#CLASE BOTON: Representa un botón en la interfaz del juego.
class Boton : 
    def __init__(self, x, y, width, height, text, font,size, color, hover_color ):    # '"ALERTA  : EN FONT TIENE QUE RECIBIR LA STRING DE LA DIRECCION DE LA FUENTE, POR EJEMPLO "fonts/arial.ttf"'
        self.rect = pg.Rect(x, y, width, height)  # Crea un rectángulo para el botón
        self.text = text  # Texto del botón
        self.font = pg.font.Font(font,size)  # Fuente del texto
        self.color = color 
        self.size = size # Color normal del botón
        self.hover_color = hover_color  # Color al pasar el mouse sobre el botón
        self.last_mouse_state  = None   # Tipo de acción (por ejemplo, cambiar de estado)
    def check_click(self):
        mouse_pos = pg.mouse.get_pos()
        mouse_pressed = pg.mouse.get_pressed()[0]
        # Detectar solo el momento exacto cuando se presiona el botón  
        if self.rect.collidepoint(mouse_pos):
            if mouse_pressed and not self.last_mouse_state:  # Solo en el frame del clic inicial
                return True  # Retorna True si el botón fue presionado
            return False
        return False

    def draw(self, surface):
        mouse_pos = pg.mouse.get_pos()  # Obtiene la posición del mouse
        if self.rect.collidepoint(mouse_pos):  # Verifica si el mouse está sobre el botón
            pg.draw.rect(surface, self.hover_color, self.rect,int(self.size*0.55),int(self.size*0.2))  # Dibuja el botón con el color de hover
        else:
            pg.draw.rect(surface, self.color, self.rect,int(self.size*0.55),int(self.size*0.2))  # Dibuja el botón con el color normal
          # Establece el tamaño de la fuente
        text_surface = self.font.render(self.text, True, (255, 255, 255))  # Renderiza el texto del botón
        text_rect = text_surface.get_rect(center=self.rect.center)  # Centra el texto en el botón
        surface.blit(text_surface, text_rect)  # Dibuja el texto en la superficie
# -------------------------------------------------------CLASES DEL JUEGO-----------
#Clase Obstaculo 
class Obstaculo:
    def __init__(self, screen, x, y):
        self.screen = screen
        self.x = x
        self.y = y
        self.rect = pg.Rect(x*CELL_SIZE, y*CELL_SIZE+100, CELL_SIZE, CELL_SIZE)
        
    def draw(self):
        pg.draw.rect(self.screen, "green", self.rect)
#-----------------------pygame------------------------------

#commons de pygame (literalmente el inicio de pygame)
pg.init()
screen = pg.display.set_mode((816, 624)) #tamano de pantalla
pg.display.set_caption("El hombre que tiraba bombas") #Nombre de la ventana
reloj = pg.time.Clock() #reloj comun para controlar FPS

#-----------------------GLOBALES------------------------------
estado = "juego" #se inicializa el estado del juego como "start", que representa el menu de inicio (ahorita esta en seleccion de pers por unas pruebas q taba haciendo)
obstacles = [] #lista de posicion de los obstacles
nivel = 1
matriz = []
#-----------------------SPRITES------------------------------


#___________________Enemigos y Aparicion de obstaculos________________________
CELL_SIZE = 48 #tamaño por celda para la aparicion de todo XDXDXDXDX
W_GRID = 17 #debido a que no es un cuadrado se debe definir un tamaño por ancho y alto
H_GRID = 13


#-------------area de juego-----------
game_surface = pg.Surface((816,524)) #superficie del juego, que es el fondo de la pantalla

#Solo para visualizar la cantidad de espacio que poseemos para jugar, o casillas. Son 187 casillas.
def draw_grid(surface):
        for row in range(W_GRID):
            for col in range(H_GRID):
                rect = pg.Rect(row*CELL_SIZE, col*CELL_SIZE+100, CELL_SIZE, CELL_SIZE)
                pg.draw.rect(surface, "gray", rect, 1)

#funcion temporal, solo genera obstacles, aunque se leeran de un txt obvio
def generate_obstacles(screen):
        global obstacles
        while len(obstacles) < 15:
            x = random.randint(0, W_GRID-1)
            y = random.randint(0, H_GRID-1)
            if (x,y) != (0,0) and (x, y) not in [(o.x, o.y) for o in obstacles]:
                obstacles.append(Obstaculo(screen, x, y))
        return obstacles

def leer_archivo(path):
        archivo = open(path, 'r')
        contenido = archivo.read()
        archivo.close()
        return contenido
def init (nivel):
        global matriz
        texto_nivel = f"Nivel_{nivel}.txt"
        matriz = eval(leer_archivo(texto_nivel))
init(nivel)

#los dibuja
def draw_obstacles():
        for obstacle in obstacles:
            obstacle.draw()
#estados de juego :
def pantalla_juego() : #ESTRO ES UN PLACEHOLDER PARA LA PANTALLA DE juego
    screen.fill("white")
    game_surface.fill("black")  # Llama al método mover del jugador 1 para dibujarlo en la pantalla
    screen.blit(game_surface,(0, 100))  # Dibuja la superficie del juego en la pantalla
    draw_grid(screen)
    generate_obstacles(screen)
    draw_obstacles()

while True:
#cambiador de estado
    if estado == "juego":  # Si el estado es "juego", se muestra la pantalla de juego
        pantalla_juego()
    else:  # Si el estado no es reconocido, se muestra un mensaje de error
        print("Estado no reconocido")
    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()
            sys.exit()  

    pg.display.flip()
    reloj.tick(45)


    
