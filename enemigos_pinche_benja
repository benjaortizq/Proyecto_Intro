import pygame as pg
import time as t
import threading
import random 
import sys 
import os 

#Aqui epiezan las clases del juego  
#----------------------------------------------------------CLASES UTILES DE PYGAME---------------------------------------

# Clase SpriteSheet: Carga una hoja de sprites y permite obtener imágenes individuales.
class SpriteSheet (): 
    def __init__(self, image): 
        self.sheet = image  # Carga la imagen de la hoja de sprites
    
    def get_image(self, frame, width, height, scale, colour):
        image = pg.Surface((width, height)).convert_alpha()     # Crea una superficie para el frame
        image.blit(self.sheet, (0, 0), ((frame * width), 0, width, height))  # Copia el frame correspondiente de la hoja de sprites
        image = pg.transform.scale(image, (width * scale, height * scale))  # Escala la imagen al tamaño deseado
        image.set_colorkey(colour)      # Establece el color clave para hacer transparente el fondo

        return image
    
#CLASE BOTON: Representa un botón en la interfaz del juego.
class Boton : 
    def __init__(self, x, y, width, height, text, font,size, color, hover_color ):    # '"ALERTA  : EN FONT TIENE QUE RECIBIR LA STRING DE LA DIRECCION DE LA FUENTE, POR EJEMPLO "fonts/arial.ttf"'
        self.rect = pg.Rect(x, y, width, height)  # Crea un rectángulo para el botón
        self.text = text  # Texto del botón
        self.font = pg.font.Font(font,size)  # Fuente del texto
        self.color = color 
        self.size = size # Color normal del botón
        self.hover_color = hover_color  # Color al pasar el mouse sobre el botón
        self.last_mouse_state  = None   # Tipo de acción (por ejemplo, cambiar de estado)
    def check_click(self):
        mouse_pos = pg.mouse.get_pos()
        mouse_pressed = pg.mouse.get_pressed()[0]
        # Detectar solo el momento exacto cuando se presiona el botón  
        if self.rect.collidepoint(mouse_pos):
            if mouse_pressed and not self.last_mouse_state:  # Solo en el frame del clic inicial
                return True  # Retorna True si el botón fue presionado
            return False
        return False

    def draw(self, surface):
        mouse_pos = pg.mouse.get_pos()  # Obtiene la posición del mouse
        if self.rect.collidepoint(mouse_pos):  # Verifica si el mouse está sobre el botón
            pg.draw.rect(surface, self.hover_color, self.rect,int(self.size*0.55),int(self.size*0.2))  # Dibuja el botón con el color de hover
        else:
            pg.draw.rect(surface, self.color, self.rect,int(self.size*0.55),int(self.size*0.2))  # Dibuja el botón con el color normal
          # Establece el tamaño de la fuente
        text_surface = self.font.render(self.text, True, (255, 255, 255))  # Renderiza el texto del botón
        text_rect = text_surface.get_rect(center=self.rect.center)  # Centra el texto en el botón
        surface.blit(text_surface, text_rect)  # Dibuja el texto en la superficie
# -------------------------------------------------------CLASES DEL JUEGO-----------
#Clase Obstaculo 
class Obstaculo:
    def __init__(self, screen, x, y, texture):
        self.screen = screen
        self.x = x
        self.y = y
        self.texture = texture
        self.mask    = pg.mask.from_surface(self.texture)
        
    def draw(self):
        self.screen.blit(self.texture, (self.x, self.y+100))



#Class Enemigos
#Screen = area_juego
class Enemigos:
     def __init__(self, screen, x, y, velocidad, spritesheet_walk, frame_count, frame_w,frame_h, scale, colour, dir):
          self.screen = screen
          self.x = x
          self.y = y
          self.velocidad = velocidad
          self.current_spritesheet = spritesheet_walk
          self.frame_count = frame_count          #CAANTIDAD DE FRAMES DE LA SKIN DEL JUGAODR
          self.width_frame = frame_w
          self.height_frame = frame_h   #esto siempre es estatico. como las spritesheets son horizontales entonces esto que qeuda asi . 
          self.scale = scale                              #multiplicador de escala para el sprite
          self.colour = colour                  #color de fondo del sprite que se va a eliminar
          self.last_update = t.time()     #tiempo de la ultima actualizacion del frame
          self.current_frame = 0        #numero de frame que esta actualmente dibujandose.
          self.current_skin = self.current_spritesheet.get_image(0, 48, 48, self.scale, self.colour)
          self.mask= pg.mask.from_surface(self.current_skin)
          self.dir = dir
          

    #line_of_sight
     def move(self):
        self.animacion_skin()
        # HORIZONTAL: dir 0 ← , dir 1 →
        if self.dir in (0, 1):
            
            dx = -self.velocidad if self.dir == 0 else self.velocidad
            new_x = self.x + dx
            if dx < 0:
                 self.current_skin = pg.transform.flip(self.current_skin, True, False)
                 self.current_skin.set_colorkey('black')

            if new_x <= 0:
                 self.dir = 1
            if new_x >= 770:
                 self.dir = 0
            # límites de pantalla
            if 0 < new_x < 770:
                self.x = new_x
        # VERTICAL: dir 2 ↑ , dir 3 ↓
        elif self.dir in (2, 3):
            dy = -self.velocidad if self.dir == 2 else self.velocidad
            new_y = self.y + dy
            if new_y <= 0:
                 self.dir = 3
            if new_y >= 480:
                 self.dir = 2
            if 0 < new_y < 480:
                self.y = new_y

        # Dibujo
        self.screen.blit(self.current_skin, (self.x, self.y+100))

     def auto_move(self):
                    self.move()
                    
                    
     def rebote(self):
          #solo rebota su hay una pared
          self.dir ^= 1          

     def cambiar_spritesheet(self, nuevo_spritesheet): #esto es para cambiar la spritesheet del jugador, por ejemplo cuando se ejecuta una habilidad
        self.current_spritesheet = nuevo_spritesheet #cambia el spritesheet actual al nuevo
        self.current_frame = 0  #reinicia el frame actual a 0
        self.last_update = t.time()     #reinicia el tiempo de la ultima actualizacion para que no se salte frames al cambiar de spritesheet
    
     def animacion_skin(self) : 
        current_time = t.time()
        if current_time - self.last_update > 0.1 : # Cambio de frame cada 0.2 segundos
            self.last_update = current_time
            self.current_frame = ((self.current_frame + 1) % self.frame_count)          #El digamos asi "numero" de frame que esta actualmente dibujandose. 
        self.current_skin = self.current_spritesheet.get_image( self.current_frame, self.width_frame,  self.height_frame, self.scale, self.colour)
        self.mask = pg.mask.from_surface(self.current_skin)
    
     def colisiona_con(self, otro_objeto):
        # Calcular diferencia de posiciones (offset)
        offset_x = int(otro_objeto.x) - int(self.x)
        offset_y = int(otro_objeto.y) - int(self.y)
        return self.mask.overlap(otro_objeto.mask, (offset_x, offset_y)) is not None
     

#-----------------------pygame------------------------------

#commons de pygame (literalmente el inicio de pygame)
pg.init()
screen = pg.display.set_mode((816, 628)) #tamano de pantalla
pg.display.set_caption("El hombre que tiraba bombas") #Nombre de la ventana
reloj = pg.time.Clock() #reloj comun para controlar FPS

#-----------------------GLOBALES------------------------------
estado = "juego" #se inicializa el estado del juego como "start", que representa el menu de inicio (ahorita esta en seleccion de pers por unas pruebas q taba haciendo)
obstacles = [] #lista de colisiones con obstaculos
obstacles_R = [] #lista de los rompibles
nivel = 1 #nivel inicial
matriz = [] #la matriz extraida del nivel inicial
Lista_Enemigos_1 = [] #la lista de los enemigos, esta solo posee los enemigos del nivel 1 o los mas sencillos
primera_vez = True #debido a que ciertas cosas SOLO se deben generar una vez por nivel, como ver sus posiciones, se hace este booleano
#-----------------------SPRITES------------------------------
#Obstaculos
sps_obstacles = pg.image.load("assets\Textures\Bricks.png")
spritesheet_Obstaculos = SpriteSheet(sps_obstacles)
Obstaculo_I = spritesheet_Obstaculos.get_image(1,64,64,0.75,'white')
Obstaculo_R = spritesheet_Obstaculos.get_image(4,64,64,0.75,'white')

#Floor
sps_floor = pg.image.load("assets\Textures\Floor.png")
spritesheet_Floor = SpriteSheet(sps_floor)
Floor_corner0 = spritesheet_Floor.get_image(0,64,64,0.75,'white')
Floor_corner1 = pg.transform.rotate(Floor_corner0,90)
Floor_corner2 = pg.transform.rotate(Floor_corner0,180)
Floor_corner3 = pg.transform.rotate(Floor_corner1,180)
Floor_up = spritesheet_Floor.get_image(1,64,64,0.75,'white')
Floor_down = pg.transform.rotate(Floor_up,180)
Floor_lside = spritesheet_Floor.get_image(3,64,64,0.75,'white')
Floor_rside = pg.transform.rotate(Floor_lside,180)
Floor_nothing = spritesheet_Floor.get_image(4,64,64,0.75,'white')

#Enemigos
sps_perro_cañon = pg.image.load("assets\sprites\enemies\perro_canon\Walk.png")
spritesheet_perro_cañon = SpriteSheet(sps_perro_cañon)



#___________________Enemigos y Aparicion de obstaculos________________________
CELL_SIZE = 48 #tamaño por celda para la aparicion de todo XDXDXDXDX
W_GRID = 17 #debido a que no es un cuadrado se debe definir un tamaño por ancho y alto
H_GRID = 13


#-------------area de juego-----------
game_surface = pg.Surface((816,528)) #superficie del juego, que es el fondo de la pantalla



#Funcion que ha partir de la matriz lee las posiciones iniciales 
def save_positions(screen):
        global obstacles, matriz, Lista_Enemigos_1, obstacles_R
        for fil in range(len(matriz)):
             for col in range(len(matriz[fil])):
                  if matriz[fil][col] == '#': 
                       texture = Obstaculo_I
                       obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                       obstacles += [obs]
                       
                  if matriz[fil][col] == '*':
                       texture = Obstaculo_R
                       obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                       obstacles += [obs]
                       obstacles_R += [obs]

                  if matriz[fil][col] == 1:
                       Enemigo_perro = Enemigos(screen, (col*48), (fil*48), 1.3, spritesheet_perro_cañon, 3, 48, 48, 1, 'black', random.randint(0,3))
                       Lista_Enemigos_1 += [Enemigo_perro]

#Este genera las texturas inamovibles, los enemigos se dibujan y se tratan dentro de su propia clase
def generate(screen):
        global obstacles, matriz
        for fil in range(len(matriz)):
             for col in range(len(matriz[fil])):
                  if matriz[fil][col] == '#': 
                       texture = Obstaculo_I
                       obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                       
                       obs.draw()
                  if matriz[fil][col] == '*':
                       texture = Obstaculo_R
                       obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                       
                       obs.draw()
                  if matriz[fil][col] in (0,1):
                       if fil == 0 and col == 0:
                            texture = Floor_corner0
                            obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                            obs.draw()
                       elif fil == 0 and col == 16:
                            texture = Floor_corner3
                            obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                            obs.draw()
                       
                       elif fil == 10 and col == 16:
                            texture = Floor_corner2
                            obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                            obs.draw()
                        
                       elif fil == 10 and col == 0:
                            texture = Floor_corner1
                            obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                            obs.draw()

                       elif fil == 0:
                            texture = Floor_up
                            obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                            obs.draw()

                       elif col == 0:
                            texture = Floor_lside
                            obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                            obs.draw()
                        
                       elif col == 16: 
                            texture = Floor_rside
                            obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                            obs.draw()

                       elif fil == 10:
                            texture = Floor_down
                            obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                            obs.draw()
                        
                       else:
                            texture = Floor_nothing
                            obs = Obstaculo(screen, (col*48),(fil*48) , texture)
                            obs.draw()

                       
#Funcion para leer la matriz de nivel
def leer_archivo(path):
        archivo = open(path, 'r')
        contenido = archivo.read()
        archivo.close()
        return contenido
def init (nivel):
        global matriz
        texto_nivel = f"Nivel_{nivel}.txt"
        matriz = eval(leer_archivo(texto_nivel))
init(nivel)



#estados de juego :
def pantalla_juego() : #ESTRO ES UN PLACEHOLDER PARA LA PANTALLA DE juego
    screen.fill("white")
    game_surface.fill("black")  # Llama al método mover del jugador 1 para dibujarlo en la pantalla
    screen.blit(game_surface,(0, 100))  # Dibuja la superficie del juego en la pantalla
    
    
    if primera_vez:
        save_positions(screen)

    generate(screen)
    for ene_1 in Lista_Enemigos_1:
        ene_1.auto_move()
        #obstaculos funciona con la mascara de los obstaculos, asi pues para hacer colisiones solo ve si hay choque entre mascaras
        for obst in obstacles:
             if Enemigos.colisiona_con(ene_1, obst):
                # aquí ya chocaron
                ene_1.rebote()

        

#ciclo principal
while True:
#cambiador de estado
    if estado == "juego":  # Si el estado es "juego", se muestra la pantalla de juego
        pantalla_juego()
        primera_vez = False
        
    else:  # Si el estado no es reconocido, se muestra un mensaje de error
        print("Estado no reconocido")
    for event in pg.event.get():
        if event.type == pg.QUIT:
            pg.quit()
            sys.exit()  

    pg.display.flip()
    reloj.tick(45)


    
